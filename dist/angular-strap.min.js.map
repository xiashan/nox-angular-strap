{"version":3,"sources":["angular-strap.js","modal/modal.js","helpers/compiler.js","datepicker/datepicker.js","tooltip/tooltip.js","timepicker/timepicker.js","sort/sort.js","tab/tab.js","popover/popover.js","select/select.js","pagination/pagination.js","helpers/raf.js","helpers/parse-options.js","helpers/dimensions.js","helpers/debounce.js","helpers/date-parser.js","helpers/date-formatter.js","dropdown/dropdown.js","alert/alert.js","module.js"],"names":["customClass","undefined","templateUrl","options","cache","$templateCache","then","element","res","fetchTemplate","template","fetchPromises","module","$http","get","defaults","animation","prefixClass","data","this","compile","controller","console","controllerAs","resolve","copy","locals","bindToController","angular","forEach","value","isString","$injector","key","invoke","transformTemplate","identity","extend","$template","when","$q","all","templateEl","Error","findElement","contentTemplate","templates","contentEl","removeAttr","html","replace","next","remove","outerHTML","link","scope","trim","contents","linkFn","invokeCtrl","children","instance","ctrl","isObject","arguments","apply","bsCompilerService","$inject","placement","provider","container","backdrop","keyboard","show","size","zIndex","$get","requestAnimationFrame","bodyElement","backdropCount","dialogBaseZindex","validSizes","ModalFactory","config","$modal","$emit","prefixEvent","isDefined","onShow","isFunction","leaveAnimateCallback","removeClass","onHide","length","$isShown","unbindBackdropEvents","modalElement","off","hideOnBackdropClick","backdropElement","preventEventDefault","bindKeyboardEvents","on","$onKeyUp","focus","evt","preventDefault","modalScope","$destroy","setScrollBar","scrollDiv","append","scrollbarWidth","offsetWidth","fullWindowWidth","documentElementRect","documentElement","bodyIsOverflowing","document","clientWidth","window","innerWidth","resetScrollBar","getBoundingClientRect","right","Math","abs","left","body","parseInt","backdropBaseZindex","$scope","$new","$rootScope","id","$id","attr","$show","$sce","trustAsHtml","$$postDigest","hide","toggle","init","compileData","promise","destroy","destroyModalElement","parent","after","isElement","z-index","$element","clonedElement","css","onBeforeShow","display","defaultPrevented","addClass","$animate","enter","minor","backdropAnimation","el","enterAnimateCallback","safeDigest","bindBackdropEvents","version","leave","onBeforeHide","unbindKeyboardEvents","which","directive","$root","$$phase","$digest","restrict","query","querySelectorAll","lg","sm","$window","setTimeout","$options","falseValueRegExp","test","bsKey","modalClass","$observe","charAt","newValue","oldValue","$eval","$watch","bsModal","modal","trigger","$on","target","titleTemplate","title","type","delay","autoClose","bsEnabled","mouseDownPreventDefault","mouseDownStopPropagation","viewport","selector","padding","TooltipFactory","$tooltip","$bsCompiler","split","clearTimeout","hoverState","destroyTipElement","_tipToHide","triggers","nodeName","isTouch","unbindTriggerEvents","$onFocusElementMouseDown","i","tipElement","_autoCloseEventsBinded","bindAutoCloseEvents","$timeout","$body","unbindAutoCloseEvents","stopEventPropagation","event","getPosition","elRect","rect","p","width","height","top","dimensions","offset","scroll","outerDims","isBody","scrollTop","prop","innerHeight","position","actualWidth","actualHeight","marginLeft","isNaN","setOffset","using","props","marginTop","tip","offsetHeight","getViewportAdjustedDelta","delta","isVertical","arrowDelta","replaceArrow","arrowOffsetPosition","viewportDimensions","$viewport","topEdgeOffset","bottomEdgeOffset","viewportPadding","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","$arrow","timeout","tipScope","$promise","toLowerCase","map","parseFloat","$setEnabled","$hide","setEnabled","isEnabled","tipContainer","bindTriggerEvents","lastChild","visibility","prepend","$$rAF","$applyPlacement","_blur","autoPlace","autoToken","elementPosition","tipWidth","tipHeight","viewportPosition","originalPlacement","tipPosition","getCalculatedOffset","applyPlacement","blur","stopPropagation","isNative","tooltip","transclusion","dataTarget","slice","hasOwnProperty","bsTooltip","bsShow","match","setViewport","useNative","timeType","timeFormat","timezone","modelTimeFormat","autoclose","minTime","maxTime","Infinity","hourStep","minuteStep","secondStep","roundDisplay","iconUp","iconDown","arrowBehavior","$timepicker","timepickerFactory","formatDate","format","viewDate","hour","startDate","getHours","meridian","coeff","selRange","select","end","start","setSelectionRange","isUndefined","collapse","selectionStart","moveStart","selectionEnd","moveEnd","focusElement","_init","parentScope","floorMinutes","time","floor","lang","selectedIndex","date","defaultDate","second","getSeconds","millisecond","getMilliseconds","$dateValue","hoursFormat","$dateFormatter","timeSeparator","minute","minutesFormat","secondsFormat","showSeconds","$iconUp","index","$moveIndex","$switchMeridian","switchMeridian","isDate","getMinutes","getTime","$build","$isBuilt","$render","keep","Date","setHours","setMinutes","setSeconds","$setViewValue","midIndex","hours","push","disabled","label","selected","minutes","$date","seconds","rows","$isDisabled","showAM","$isSelected","isAM","selectedTime","$arrowAction","$setTimeByStep","newDate","targetDate","$onMouseDown","targetEl","triggerHandler","$onKeyDown","keyCode","hoursLength","minutesLength","sepLength","lateralMove","count","selectRange","incr","isSeconds","isMeridian","secondsLength","createSelection","createTextRange","_destroy","_show","_hide","require","navigator","userAgent","isMaxValid","isValid","parsedTime","isMinValid","setFullYear","$setValidity","$parsers","unshift","viewValue","getTimeFormattedString","timepicker","dateParser","$dateParser","validateAgainstMinMaxTime","ngModel","update","timezoneOffsetAdjust","$formatters","modelValue","NaN","parse","item","attrs","list","len","postLink","dataName","toUpperCase","currentTarget","$apply","orderBy","sortBy","onSort","clickColumn","self","navClass","activeClass","$activeClass","$panes","$activePaneChangeListeners","$push","pane","$active","$attrs","$navClass","$remove","active","activeIndex","indexOf","splice","$setActive","name","fn","$pane","$tab","transclude","ngModelCtrl","bsTabsCtrl","bsActivePane","parsedBsActivePane","assign","$parse","controllers","render","$isActive","content","$popover","PopoverFactory","bsPopover","popover","multiple","allNoneButtons","sort","caretHtml","placeholder","allText","noneText","maxLength","maxLengthHtml","iconCheckmark","SelectFactory","$select","$activeIndex","$isMultiple","$showAllNoneButtons","$iconCheckmark","$allText","$activate","activate","$isVisible","$selectNone","$matches","matches","$updateActiveIndex","a","b","onSelect","isArray","$modelValue","$getIndex","minLength","$viewValue","equals","anchor","anchorCandidate","$selectScrollFix","$isIE","stopImmediatePropagation","ua","activeElement","tagName","e","dataMultiple","inputEl","addEventListener","watchedOptions","parsedOptions","valuesFn","values","$match","filter","join","$isEmpty","calculateTotalPages","pageClass","totalPages","pagesLength","itemsPerPage","makePage","number","text","isActive","max","getPages","currentPage","pages","half","ceil","$pagination","bsPaginationCtrl","totalItems","page","selectPage","onChange","noPrevious","noNext","selectPrevious","factory","dot","cancelAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","rafSupported","raf","timer","cancel","supported","$parseOptions","$values","regexp","valueName","keyName","displayFn","valueFn","ParseOptionsFactory","groupByFn","displayValue","offsetParent","docElement","ownerDocument","outer","getComputedStyle","extra","currentStyle","boxRect","style","curPosition","curLeft","curCSSTop","curTop","calculatePosition","curElem","curCSSLeft","curOffset","call","offsetParentRect","offsetParentEl","offsetParentElement","func","immediate","args","context","callNow","leading","wait","trailing","year","$localeProvider","milliseconds","ParseDate","prototype","noop","array","indexOfCaseInsensitive","str","toString","strict","DateParserFactory","day","month","getFullYear","getMonth","proto","isNumeric","toDate","regExpMap","sss","$locale","dateFilter","mm","literalRegex","formatParts","escapedLiteralFormat","dateElements","keys","escapedFormat","isFormatStringLiteral","part","trimLiteralEscapeChars","dateRegexParts","escapeReservedSymbols","re","abstractRegex","buildDateParseRegex","setMapForFormat","buildDateAbstractRegex","buildDateParseValuesMap","Object","valuesMatch","keyIndex","valueKey","valuesFunctionMap","valueFunction","valuesRegex","exec","setFnMap","setMap","m","HH","H","hh","h","EEEE","EEE","DATETIME_FORMATS","SHORTDAY","dd","d","MMMM","MMM","SHORTMONTH","MM","M","DAY","yyyy","yy","y","MONTH","ss","s","setDate","setMonth","regex","$format","regExpForFormat","baseDate","formatRegex","formatSetMap","fromDate","getDate","today","getDateForAttribute","substr","getTimeForAttribute","daylightSavingAdjust","undo","getTimezoneOffset","getDefaultLocale","getDatetimeFormat","weekdaysShort","splitTimeFormat","service","dateType","dateFormat","modelDateFormat","dayFormat","monthFormat","yearFormat","monthTitleFormat","yearTitleFormat","strictFormat","minDate","maxDate","startView","minView","startWeek","daysOfWeekDisabled","hasToday","hasClear","iconLeft","iconRight","DatepickerFactory","$datepicker","pickerViews","views","$iconLeft","$iconRight","$hasToday","$picker","$selectPane","$hasClear","$toggleMode","$views","$mode","setMode","$setToday","$clear","updateDisabledDates","disabledDateRanges","dateRanges","$setDisabledEl","mode","pristine","$updateSelected","built","isDisabled","steps","getUTCFullYear","getUTCMonth","UTC","getUTCDate","shiftKey","altKey","onKeyDown","datepickerViews","previousValue","normalizeDateRanges","ranges","disabledRanges","datepicker","parsedDate","getDateFormattedString","validateAgainstMinMaxDate","disabledDates","arrays","mod","n","arr","weekDaysMin","weekDaysLabelsHtml","picker","weekDaysLabels","concat","firstDayOfMonth","firstDayOfMonthOffset","firstDate","firstDateOffset","build","days","isToday","toDateString","muted","showLabels","labels","isTodayDisabled","isSelected","getDay","months","lastDate","actualMonth","firstYear","years","actualYear","Array","setYear","bodyEl","matchesSelector","DropdownFactory","$dropdown","onBodyClick","items","parentEl","hasClass","tAttrs","nextSibling","nodeType","parentNode","removeChild","dropdown","duration","dismissible","AlertFactory","$alert","bsAlert","alert"],"mappings":"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","file":"angular-strap.min.js","sourcesContent":["(function(window, document, undefined) {\n'use strict';\n\n// Source: modal/modal.js\nangular.module('mgcrea.ngStrap.modal', [ 'mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions' ])\n  .provider('$modal', function() {\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      backdropAnimation: 'am-fade',\n      customClass: '',\n      prefixClass: 'modal',\n      prefixEvent: 'modal',\n      placement: 'top',\n      templateUrl: 'modal/modal.tpl.html',\n      template: '',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true,\n      size: null,\n      zIndex: null\n    };\n    this.$get = [ '$window', '$rootScope', '$bsCompiler', '$animate', '$timeout', '$sce', 'dimensions', function($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\n      var forEach = angular.forEach;\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n      var bodyElement = angular.element($window.document.body);\n      var backdropCount = 0;\n      var dialogBaseZindex = 1050;\n      var backdropBaseZindex = 1040;\n      var validSizes = {\n        lg: 'modal-dialog-lg',\n        sm: 'modal-dialog-sm'\n      };\n      function ModalFactory(config) {\n        var $modal = {};\n        var options = $modal.$options = angular.extend({}, defaults, config);\n        var promise = $modal.$promise = $bsCompiler.compile(options);\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if (!options.element && !options.container) {\n          options.container = 'body';\n        }\n        if (options.zIndex) {\n          dialogBaseZindex = parseInt(options.zIndex, 10);\n          backdropBaseZindex = dialogBaseZindex - 10;\n        }\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\n        forEach([ 'title', 'content' ], function(key) {\n          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);\n        });\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $modal.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $modal.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $modal.toggle();\n          });\n        };\n        $modal.$isShown = scope.$isShown = false;\n        var compileData;\n        var modalElement;\n        var modalScope;\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\n        promise.then(function(data) {\n          compileData = data;\n          $modal.init();\n        });\n        $modal.init = function() {\n          if (options.show) {\n            scope.$$postDigest(function() {\n              $modal.show();\n            });\n          }\n        };\n        $modal.destroy = function() {\n          destroyModalElement();\n          if (backdropElement) {\n            backdropElement.remove();\n            backdropElement = null;\n          }\n          scope.$destroy();\n        };\n        $modal.show = function() {\n          if ($modal.$isShown) return;\n          var parent;\n          var after;\n          if (angular.isElement(options.container)) {\n            parent = options.container;\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\n          }\n          else {\n            if (options.container) {\n              parent = findElement(options.container);\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\n            } else {\n              parent = null;\n              after = options.element;\n            }\n          }\n          if (options.backdrop) {\n            setScrollBar();\n          }\n          if (modalElement) {\n            destroyModalElement();\n          }\n          modalScope = $modal.$scope.$new();\n          modalElement = $modal.$element = compileData.link(modalScope, function(clonedElement, scope) {});\n          if (options.backdrop) {\n            modalElement.css({\n              'z-index': dialogBaseZindex + backdropCount * 20\n            });\n            backdropElement.css({\n              'z-index': backdropBaseZindex + backdropCount * 20\n            });\n            backdropCount++;\n          }\n          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\n            return;\n          }\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\n            options.onBeforeShow($modal);\n          }\n          modalElement.css({\n            display: 'block'\n          }).addClass(options.placement);\n          if (options.customClass) {\n            modalElement.addClass(options.customClass);\n          }\n          if (options.size && validSizes[options.size]) {\n            angular.element(findElement('.modal-dialog', modalElement[0])).addClass(validSizes[options.size]);\n          }\n          if (options.animation) {\n            if (options.backdrop) {\n              backdropElement.addClass(options.backdropAnimation);\n            }\n            modalElement.addClass(options.animation);\n          }\n          if (options.backdrop) {\n            $animate.enter(backdropElement, bodyElement, null);\n          }\n          if (angular.version.minor <= 2) {\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\n          }\n          $modal.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n          var el = modalElement[0];\n          requestAnimationFrame(function() {\n            el.focus();\n          });\n          bodyElement.addClass(options.prefixClass + '-open');\n          if (options.animation) {\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\n          }\n          bindBackdropEvents();\n          bindKeyboardEvents();\n        };\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $modal);\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\n            options.onShow($modal);\n          }\n        }\n        $modal.hide = function() {\n          if (!$modal.$isShown) return;\n          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\n            return;\n          }\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\n            options.onBeforeHide($modal);\n          }\n          if (angular.version.minor <= 2) {\n            $animate.leave(modalElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(modalElement).then(leaveAnimateCallback);\n          }\n          if (options.backdrop) {\n            backdropCount--;\n            $animate.leave(backdropElement);\n          }\n          $modal.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n          unbindBackdropEvents();\n          unbindKeyboardEvents();\n        };\n        function leaveAnimateCallback() {\n          if (options.backdrop) {\n            resetScrollBar();\n          }\n          scope.$emit(options.prefixEvent + '.hide', $modal);\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\n            options.onHide($modal);\n          }\n          if (findElement('.modal').length <= 0) {\n            bodyElement.removeClass(options.prefixClass + '-open');\n          }\n          if (options.animation) {\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\n          }\n        }\n        $modal.toggle = function() {\n          if ($modal.$isShown) {\n            $modal.hide();\n          } else {\n            $modal.show();\n          }\n        };\n        $modal.focus = function() {\n          modalElement[0].focus();\n        };\n        $modal.$onKeyUp = function(evt) {\n          if (evt.which === 27 && $modal.$isShown) {\n            $modal.hide();\n            evt.stopPropagation();\n          }\n        };\n        function bindBackdropEvents() {\n          if (options.backdrop) {\n            modalElement.on('click', hideOnBackdropClick);\n            backdropElement.on('click', hideOnBackdropClick);\n            backdropElement.on('wheel', preventEventDefault);\n          }\n        }\n        function unbindBackdropEvents() {\n          if (options.backdrop) {\n            modalElement.off('click', hideOnBackdropClick);\n            backdropElement.off('click', hideOnBackdropClick);\n            backdropElement.off('wheel', preventEventDefault);\n          }\n        }\n        function bindKeyboardEvents() {\n          if (options.keyboard) {\n            modalElement.on('keyup', $modal.$onKeyUp);\n          }\n        }\n        function unbindKeyboardEvents() {\n          if (options.keyboard) {\n            modalElement.off('keyup', $modal.$onKeyUp);\n          }\n        }\n        function hideOnBackdropClick(evt) {\n          if (evt.target !== evt.currentTarget) return;\n          if (options.backdrop === 'static') {\n            $modal.focus();\n          } else {\n            $modal.hide();\n          }\n        }\n        function preventEventDefault(evt) {\n          evt.preventDefault();\n        }\n        function destroyModalElement() {\n          if ($modal.$isShown && modalElement !== null) {\n            unbindBackdropEvents();\n            unbindKeyboardEvents();\n          }\n          if (modalScope) {\n            modalScope.$destroy();\n            modalScope = null;\n          }\n          if (modalElement) {\n            modalElement.remove();\n            modalElement = $modal.$element = null;\n          }\n        }\n        function setScrollBar() {\n          var scrollDiv = document.createElement('div');\n          scrollDiv.className = 'modal-scrollbar-measure';\n          bodyElement.append(scrollDiv);\n          var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n          bodyElement[0].removeChild(scrollDiv);\n\n          var fullWindowWidth = window.innerWidth;\n          if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8\n            var documentElementRect = document.documentElement.getBoundingClientRect();\n            fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);\n          }\n          var bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;\n\n          if (bodyIsOverflowing) bodyElement.css('padding-right', scrollbarWidth + 'px');\n        }\n        function resetScrollBar() {\n          bodyElement.css('padding-right', 0);\n        }\n        return $modal;\n      }\n      function safeDigest(scope) {\n        scope.$$phase || scope.$root && scope.$root.$$phase || scope.$digest();\n      }\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n      return ModalFactory;\n    } ];\n  }).directive('bsModal', [ '$window', '$sce', '$parse', '$modal', function($window, $sce, $parse, $modal) {\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n        var options = {\n          scope: scope,\n          element: element,\n          show: false\n        };\n        angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass', 'size', 'zIndex' ], function(key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n        if (options.modalClass) {\n          options.customClass = options.modalClass;\n        }\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach([ 'backdrop', 'keyboard', 'html', 'container' ], function(key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n        angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide' ], function(key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n        angular.forEach([ 'title', 'content' ], function(key) {\n          if (attr[key]) {\n            attr.$observe(key, function(newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n        if (attr.bsModal) {\n          scope.$watch(attr.bsModal, function(newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n        var modal = $modal(options);\n        element.on(attr.trigger || 'click', modal.toggle);\n        scope.$on('$destroy', function() {\n          if (modal) modal.destroy();\n          options = null;\n          modal = null;\n        });\n      }\n    };\n  } ]);\n\n// Source: tooltip/tooltip.js\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      titleTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      mouseDownPreventDefault: true,\n      mouseDownStopPropagation: true,\n      viewport: {\n        selector: 'body',\n        padding: 0\n      }\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory (element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if (options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if (options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function (isEnabled) {\n          scope.$$postDigest(function () {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout;\n        var hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData;\n        var tipElement;\n        var tipContainer;\n        var tipScope;\n        promise.then(function (data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function () {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if (options.container === 'self') {\n            tipContainer = element;\n          } else if (angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if (options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if (options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              if (options.trigger === 'focus') {\n                element[0].focus();\n              } else {\n                $tooltip.show();\n              }\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function () {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function () {\n            if (hoverState === 'in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function () {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\n            options.onBeforeShow($tooltip);\n          }\n          var parent;\n          var after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if (tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if (options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if (options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          if (after) {\n            after.after(tipElement);\n          } else {\n            parent.prepend(tipElement);\n          }\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if (tipElement) tipElement.css({visibility: 'visible'});\n\n            // Bind events\n            if (options.keyboard) {\n              if (options.trigger !== 'focus') {\n                $tooltip.focus();\n              }\n              bindKeyboardEvents();\n            }\n          });\n\n          if (options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\n            options.onShow($tooltip);\n          }\n        }\n\n        $tooltip.leave = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function (blur) {\n\n          if (!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\n            options.onBeforeHide($tooltip);\n          }\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.leave(tipElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(tipElement).then(leaveAnimateCallback);\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if (options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if (options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\n            options.onHide($tooltip);\n          }\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if (_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function (evt) {\n          if (evt) { evt.preventDefault(); }\n          if ($tooltip.$isShown) {\n            $tooltip.leave();\n          } else {\n            $tooltip.enter();\n          }\n        };\n\n        $tooltip.focus = function () {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function (isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function (viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function () {\n          if (!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement;\n          var autoToken = /\\s?auto?\\s?/i;\n          var autoPlace = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition();\n          var tipWidth = tipElement.prop('offsetWidth');\n          var tipHeight = tipElement.prop('offsetHeight');\n\n          // Refresh viewport position\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var viewportPosition = getPosition($tooltip.$viewport);\n\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\n              placement = placement.replace('left', 'right');\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\n              placement = placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function (evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function (evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function (evt) {\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          if ($tooltip.$isShown) {\n            element[0].blur();\n          } else {\n            element[0].focus();\n          }\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function (trigger) {\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.on(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          });\n        }\n\n        function unbindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.off(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          }\n        }\n\n        function bindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents () {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents () {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation (event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition ($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0];\n          var isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          /* eslint-disable guard-for-in */\n          for (var p in elRect) { // eslint-disable-line\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n          /* eslint-enable guard-for-in */\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\n          }\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n            case 'right':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left + position.width\n              };\n              break;\n            case 'bottom':\n              offset = {\n                top: position.top + position.height,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n            case 'left':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left - actualWidth\n              };\n              break;\n            default:\n              offset = {\n                top: position.top - actualHeight,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n          }\n\n          if (!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if (split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n              case 'left':\n                offset.left = position.left;\n                break;\n              case 'right':\n                offset.left = position.left + position.width - actualWidth;\n                break;\n              default:\n                break;\n            }\n          } else if (split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n              case 'top':\n                offset.top = position.top - actualHeight + position.height;\n                break;\n              case 'bottom':\n                offset.top = position.top;\n                break;\n              default:\n                break;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement (offset, placement) {\n          var tip = tipElement[0];\n          var width = tip.offsetWidth;\n          var height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth;\n          var actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement);\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow (delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement () {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if ($tooltip.$isShown && tipElement !== null) {\n            if (options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if (options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if (tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if (tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest (scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement (query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n\n        var tooltip;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function (newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }\n        });\n\n        attr.$observe('disabled', function (newValue) {\n          if (newValue && tooltip.$isShown) {\n            tooltip.hide();\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsTooltip) {\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.title = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n            if (newValue === true) {\n              tooltip.show();\n            } else {\n              tooltip.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n            if (newValue === false) {\n              tooltip.setEnabled(false);\n            } else {\n              tooltip.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            tooltip.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: timepicker/timepicker.js\nangular.module('mgcrea.ngStrap.timepicker', [ 'mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip' ]).provider('$timepicker', function() {\n  var defaults = this.defaults = {\n    animation: 'am-fade',\n    defaultDate: 'auto',\n    prefixClass: 'timepicker',\n    placement: 'bottom-left',\n    templateUrl: 'timepicker/timepicker.tpl.html',\n    trigger: 'focus',\n    container: false,\n    keyboard: true,\n    html: false,\n    delay: 0,\n    useNative: true,\n    timeType: 'date',\n    timeFormat: 'shortTime',\n    timezone: null,\n    modelTimeFormat: null,\n    autoclose: false,\n    minTime: -Infinity,\n    maxTime: +Infinity,\n    length: 5,\n    hourStep: 1,\n    minuteStep: 5,\n    secondStep: 5,\n    roundDisplay: false,\n    iconUp: 'nox-sort-up',\n    iconDown: 'nox-sort-down',\n    arrowBehavior: 'pager'\n  };\n  this.$get = [ '$window', '$document', '$rootScope', '$sce', '$dateFormatter', '$tooltip', '$timeout', function($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n    var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);\n    var isTouch = 'createTouch' in $window.document && isNative;\n    if (!defaults.lang) {\n      defaults.lang = $dateFormatter.getDefaultLocale();\n    }\n    function timepickerFactory(element, controller, config) {\n      var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n      var parentScope = config.scope;\n      var options = $timepicker.$options;\n      var scope = $timepicker.$scope;\n      var lang = options.lang;\n      var formatDate = function(date, format, timezone) {\n        return $dateFormatter.formatDate(date, format, lang, timezone);\n      };\n      function floorMinutes(time) {\n        var coeff = 1e3 * 60 * options.minuteStep;\n        return new Date(Math.floor(time.getTime() / coeff) * coeff);\n      }\n      var selectedIndex = 0;\n      var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n      var startDate = controller.$dateValue || defaultDate;\n      var viewDate = {\n        hour: startDate.getHours(),\n        meridian: startDate.getHours() < 12,\n        minute: startDate.getMinutes(),\n        second: startDate.getSeconds(),\n        millisecond: startDate.getMilliseconds()\n      };\n      var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n      var hoursFormat = $dateFormatter.hoursFormat(format);\n      var timeSeparator = $dateFormatter.timeSeparator(format);\n      var minutesFormat = $dateFormatter.minutesFormat(format);\n      var secondsFormat = $dateFormatter.secondsFormat(format);\n      var showSeconds = $dateFormatter.showSeconds(format);\n      var showAM = $dateFormatter.showAM(format);\n      scope.$iconUp = options.iconUp;\n      scope.$iconDown = options.iconDown;\n      scope.$select = function(date, index) {\n        $timepicker.select(date, index);\n      };\n      scope.$moveIndex = function(value, index) {\n        $timepicker.$moveIndex(value, index);\n      };\n      scope.$switchMeridian = function(date) {\n        $timepicker.switchMeridian(date);\n      };\n      $timepicker.update = function(date) {\n        if (angular.isDate(date) && !isNaN(date.getTime())) {\n          $timepicker.$date = date;\n          angular.extend(viewDate, {\n            hour: date.getHours(),\n            minute: date.getMinutes(),\n            second: date.getSeconds(),\n            millisecond: date.getMilliseconds()\n          });\n          $timepicker.$build();\n        } else if (!$timepicker.$isBuilt) {\n          $timepicker.$build();\n        }\n      };\n      $timepicker.select = function(date, index, keep) {\n        if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n          controller.$dateValue = options.defaultDate === 'today' ? new Date() : new Date(1970, 0, 1);\n        }\n        if (!angular.isDate(date)) date = new Date(date);\n        if (index === 0) controller.$dateValue.setHours(date.getHours()); else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes()); else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\n        controller.$setViewValue(angular.copy(controller.$dateValue));\n        controller.$render();\n        if (options.autoclose && !keep) {\n          $timeout(function() {\n            $timepicker.hide(true);\n          });\n        }\n      };\n      $timepicker.switchMeridian = function(date) {\n        if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n          return;\n        }\n        var hours = (date || controller.$dateValue).getHours();\n        controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n        controller.$setViewValue(angular.copy(controller.$dateValue));\n        controller.$render();\n      };\n      $timepicker.$build = function() {\n        var i;\n        var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n        var hours = [];\n        var hour;\n        for (i = 0; i < options.length; i++) {\n          hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n          hours.push({\n            date: hour,\n            label: formatDate(hour, hoursFormat),\n            selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\n            disabled: $timepicker.$isDisabled(hour, 0)\n          });\n        }\n        var minutes = [];\n        var minute;\n        for (i = 0; i < options.length; i++) {\n          minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n          minutes.push({\n            date: minute,\n            label: formatDate(minute, minutesFormat),\n            selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\n            disabled: $timepicker.$isDisabled(minute, 1)\n          });\n        }\n        var seconds = [];\n        var second;\n        for (i = 0; i < options.length; i++) {\n          second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\n          seconds.push({\n            date: second,\n            label: formatDate(second, secondsFormat),\n            selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\n            disabled: $timepicker.$isDisabled(second, 2)\n          });\n        }\n        var rows = [];\n        for (i = 0; i < options.length; i++) {\n          if (showSeconds) {\n            rows.push([ hours[i], minutes[i], seconds[i] ]);\n          } else {\n            rows.push([ hours[i], minutes[i] ]);\n          }\n        }\n        scope.rows = rows;\n        scope.showSeconds = showSeconds;\n        scope.showAM = showAM;\n        scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n        scope.timeSeparator = timeSeparator;\n        $timepicker.$isBuilt = true;\n      };\n      $timepicker.$isSelected = function(date, index) {\n        if (!$timepicker.$date) return false; else if (index === 0) {\n          return date.getHours() === $timepicker.$date.getHours();\n        } else if (index === 1) {\n          return date.getMinutes() === $timepicker.$date.getMinutes();\n        } else if (index === 2) {\n          return date.getSeconds() === $timepicker.$date.getSeconds();\n        }\n      };\n      $timepicker.$isDisabled = function(date, index) {\n        var selectedTime;\n        if (index === 0) {\n          selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\n        } else if (index === 1) {\n          selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\n        } else if (index === 2) {\n          selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\n        }\n        return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n      };\n      scope.$arrowAction = function(value, index) {\n        if (options.arrowBehavior === 'picker') {\n          $timepicker.$setTimeByStep(value, index);\n        } else {\n          $timepicker.$moveIndex(value, index);\n        }\n      };\n      $timepicker.$setTimeByStep = function(value, index) {\n        var newDate = new Date($timepicker.$date || startDate);\n        var hours = newDate.getHours();\n        var minutes = newDate.getMinutes();\n        var seconds = newDate.getSeconds();\n        if (index === 0) {\n          newDate.setHours(hours - parseInt(options.hourStep, 10) * value);\n        } else if (index === 1) {\n          newDate.setMinutes(minutes - parseInt(options.minuteStep, 10) * value);\n        } else if (index === 2) {\n          newDate.setSeconds(seconds - parseInt(options.secondStep, 10) * value);\n        }\n        $timepicker.select(newDate, index, true);\n      };\n      $timepicker.$moveIndex = function(value, index) {\n        var targetDate;\n        if (index === 0) {\n          targetDate = new Date(1970, 0, 1, viewDate.hour + value * options.length, viewDate.minute, viewDate.second);\n          angular.extend(viewDate, {\n            hour: targetDate.getHours()\n          });\n        } else if (index === 1) {\n          targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + value * options.length * options.minuteStep, viewDate.second);\n          angular.extend(viewDate, {\n            minute: targetDate.getMinutes()\n          });\n        } else if (index === 2) {\n          targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + value * options.length * options.secondStep);\n          angular.extend(viewDate, {\n            second: targetDate.getSeconds()\n          });\n        }\n        $timepicker.$build();\n      };\n      $timepicker.$onMouseDown = function(evt) {\n        if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n        evt.stopPropagation();\n        if (isTouch) {\n          var targetEl = angular.element(evt.target);\n          if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n            targetEl = targetEl.parent();\n          }\n          targetEl.triggerHandler('click');\n        }\n      };\n      $timepicker.$onKeyDown = function(evt) {\n        if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n        evt.preventDefault();\n        evt.stopPropagation();\n        if (evt.keyCode === 13) {\n          $timepicker.hide(true);\n          return;\n        }\n        var newDate = new Date($timepicker.$date);\n        var hours = newDate.getHours();\n        var hoursLength = formatDate(newDate, hoursFormat).length;\n        var minutes = newDate.getMinutes();\n        var minutesLength = formatDate(newDate, minutesFormat).length;\n        var seconds = newDate.getSeconds();\n        var secondsLength = formatDate(newDate, secondsFormat).length;\n        var sepLength = 1;\n        var lateralMove = /(37|39)/.test(evt.keyCode);\n        var count = 2 + showSeconds * 1 + showAM * 1;\n        if (lateralMove) {\n          if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1; else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n        }\n        var selectRange = [ 0, hoursLength ];\n        var incr = 0;\n        if (evt.keyCode === 38) incr = -1;\n        if (evt.keyCode === 40) incr = +1;\n        var isSeconds = selectedIndex === 2 && showSeconds;\n        var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\n        if (selectedIndex === 0) {\n          newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\n          hoursLength = formatDate(newDate, hoursFormat).length;\n          selectRange = [ 0, hoursLength ];\n        } else if (selectedIndex === 1) {\n          newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\n          minutesLength = formatDate(newDate, minutesFormat).length;\n          selectRange = [ hoursLength + sepLength, minutesLength ];\n        } else if (isSeconds) {\n          newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\n          secondsLength = formatDate(newDate, secondsFormat).length;\n          selectRange = [ hoursLength + sepLength + minutesLength + sepLength, secondsLength ];\n        } else if (isMeridian) {\n          if (!lateralMove) $timepicker.switchMeridian();\n          selectRange = [ hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2 ];\n        }\n        $timepicker.select(newDate, selectedIndex, true);\n        createSelection(selectRange[0], selectRange[1]);\n        parentScope.$digest();\n      };\n      function createSelection(start, length) {\n        var end = start + length;\n        if (element[0].createTextRange) {\n          var selRange = element[0].createTextRange();\n          selRange.collapse(true);\n          selRange.moveStart('character', start);\n          selRange.moveEnd('character', end);\n          selRange.select();\n        } else if (element[0].setSelectionRange) {\n          element[0].setSelectionRange(start, end);\n        } else if (angular.isUndefined(element[0].selectionStart)) {\n          element[0].selectionStart = start;\n          element[0].selectionEnd = end;\n        }\n      }\n      function focusElement() {\n        element[0].focus();\n      }\n      var _init = $timepicker.init;\n      $timepicker.init = function() {\n        if (isNative && options.useNative) {\n          element.prop('type', 'time');\n          element.css('-webkit-appearance', 'textfield');\n          return;\n        } else if (isTouch) {\n          element.prop('type', 'text');\n          element.attr('readonly', 'true');\n          element.on('click', focusElement);\n        }\n        _init();\n      };\n      var _destroy = $timepicker.destroy;\n      $timepicker.destroy = function() {\n        if (isNative && options.useNative) {\n          element.off('click', focusElement);\n        }\n        _destroy();\n      };\n      var _show = $timepicker.show;\n      $timepicker.show = function() {\n        if (!isTouch && element.attr('readonly') || element.attr('disabled')) return;\n        _show();\n        $timeout(function() {\n          if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.on('keydown', $timepicker.$onKeyDown);\n          }\n        }, 0, false);\n      };\n      var _hide = $timepicker.hide;\n      $timepicker.hide = function(blur) {\n        if (!$timepicker.$isShown) return;\n        if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n        if (options.keyboard) {\n          if (element) element.off('keydown', $timepicker.$onKeyDown);\n        }\n        _hide(blur);\n      };\n      return $timepicker;\n    }\n    timepickerFactory.defaults = defaults;\n    return timepickerFactory;\n  } ];\n}).directive('bsTimepicker', [ '$window', '$parse', '$q', '$dateFormatter', '$dateParser', '$timepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n  var defaults = $timepicker.defaults;\n  var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);\n  return {\n    restrict: 'EAC',\n    require: 'ngModel',\n    link: function postLink(scope, element, attr, controller) {\n      var options = {\n        scope: scope\n      };\n      angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent', 'defaultDate' ], function(key) {\n        if (angular.isDefined(attr[key])) options[key] = attr[key];\n      });\n      var falseValueRegExp = /^(false|0|)$/i;\n      angular.forEach([ 'html', 'container', 'autoclose', 'useNative', 'roundDisplay' ], function(key) {\n        if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n          options[key] = false;\n        }\n      });\n      angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide' ], function(key) {\n        var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n        if (angular.isDefined(attr[bsKey])) {\n          options[key] = scope.$eval(attr[bsKey]);\n        }\n      });\n      if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n      var timepicker = $timepicker(element, controller, options);\n      options = timepicker.$options;\n      var lang = options.lang;\n      var formatDate = function(date, format, timezone) {\n        return $dateFormatter.formatDate(date, format, lang, timezone);\n      };\n      if (attr.bsShow) {\n        scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if (!timepicker || !angular.isDefined(newValue)) return;\n          if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n          if (newValue === true) {\n            timepicker.show();\n          } else {\n            timepicker.hide();\n          }\n        });\n      }\n      var dateParser = $dateParser({\n        format: options.timeFormat,\n        lang: lang\n      });\n      angular.forEach([ 'minTime', 'maxTime' ], function(key) {\n        if (angular.isDefined(attr[key])) {\n          attr.$observe(key, function(newValue) {\n            timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n            if (!isNaN(timepicker.$options[key])) timepicker.$build();\n            validateAgainstMinMaxTime(controller.$dateValue);\n          });\n        }\n      });\n      scope.$watch(attr.ngModel, function(newValue, oldValue) {\n        timepicker.update(controller.$dateValue);\n      }, true);\n      function validateAgainstMinMaxTime(parsedTime) {\n        if (!angular.isDate(parsedTime)) return;\n        var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n        var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n        var isValid = isMinValid && isMaxValid;\n        controller.$setValidity('date', isValid);\n        controller.$setValidity('min', isMinValid);\n        controller.$setValidity('max', isMaxValid);\n        if (!isValid) {\n          return;\n        }\n        controller.$dateValue = parsedTime;\n      }\n      controller.$parsers.unshift(function(viewValue) {\n        var date;\n        if (!viewValue) {\n          controller.$setValidity('date', true);\n          return null;\n        }\n        var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n        if (!parsedTime || isNaN(parsedTime.getTime())) {\n          controller.$setValidity('date', false);\n          return undefined;\n        }\n        validateAgainstMinMaxTime(parsedTime);\n        if (options.timeType === 'string') {\n          date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n          return formatDate(date, options.modelTimeFormat || options.timeFormat);\n        }\n        date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n        if (options.timeType === 'number') {\n          return date.getTime();\n        } else if (options.timeType === 'unix') {\n          return date.getTime() / 1e3;\n        } else if (options.timeType === 'iso') {\n          return date.toISOString();\n        }\n        return new Date(date);\n      });\n      controller.$formatters.push(function(modelValue) {\n        var date;\n        if (angular.isUndefined(modelValue) || modelValue === null) {\n          date = NaN;\n        } else if (angular.isDate(modelValue)) {\n          date = modelValue;\n        } else if (options.timeType === 'string') {\n          date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n        } else if (options.timeType === 'unix') {\n          date = new Date(modelValue * 1e3);\n        } else {\n          date = new Date(modelValue);\n        }\n        controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n        return getTimeFormattedString();\n      });\n      controller.$render = function() {\n        element.val(getTimeFormattedString());\n      };\n      function getTimeFormattedString() {\n        return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n      }\n      scope.$on('$destroy', function() {\n        if (timepicker) timepicker.destroy();\n        options = null;\n        timepicker = null;\n      });\n    }\n  };\n} ]);\n\n// Source: sort/sort.js\nangular.module('mgcrea.ngStrap.sort', []).directive('bsSort', [function() {\n  return {\n    scope: true,\n    compile: function(element, attrs) {\n      var list = element[0].querySelectorAll('th');\n      for (var i = 0, len = list.length; i < len; i++) {\n        var item = list[i];\n        item = angular.element(item);\n        if (item.attr('data-sortable')) {\n          var dataName = item.attr('data-name');\n          item.append('<div class=\"sorter\"><i class=\"nox-sort-up sort-asc\" ng-class=\"{active: orderBy == \\'' + dataName + '\\' && sortBy == \\'asc\\'}\"></i><i class=\"nox-sort-down sort-desc\" ng-class=\"{active: orderBy == \\'' + dataName + '\\' && sortBy == \\'desc\\'}\"></i></div>');\n        }\n      }\n\n      return function postLink (scope, element, attrs) {\n        var options = {\n          scope: scope,\n          element: element,\n          show: false\n        };\n        angular.forEach(['onSort'], function(key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attrs[bsKey])) {\n            options[key] = scope.$eval(attrs[bsKey]);\n          }\n        });\n        var list = element[0].querySelectorAll('th');\n        for (var i = 0, len = list.length; i < len; i++) {\n          var item = list[i];\n          item = angular.element(item);\n          if (item.attr('data-sortable')) {\n            item.on('click', clickColumn)\n          }\n        }\n\n        function clickColumn(event) {\n          var target = angular.element(event.currentTarget);\n          var dataName = target.attr('data-name');\n          if (dataName === scope.orderBy) {\n            scope.sortBy = scope.sortBy === 'asc' ? 'desc' : 'asc';\n          }\n          else {\n            scope.orderBy = dataName;\n            scope.sortBy = 'asc';\n          }\n          scope.$apply();\n\n          if (angular.isDefined(options.onSort) && angular.isFunction(options.onSort)) {\n            options.onSort(scope.orderBy, scope.sortBy);\n          }\n        }\n\n      }\n\n    }\n  };\n} ]);\n\n// Source: tab/tab.js\nangular.module('mgcrea.ngStrap.tab', []).provider('$tab', function() {\n  var defaults = this.defaults = {\n    animation: 'am-fade',\n    template: 'tab/tab.tpl.html',\n    navClass: 'nav-tabs',\n    activeClass: 'active'\n  };\n  var controller = this.controller = function($scope, $element, $attrs) {\n    var self = this;\n    self.$options = angular.copy(defaults);\n    angular.forEach([ 'animation', 'navClass', 'activeClass' ], function(key) {\n      if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n    });\n    $scope.$navClass = self.$options.navClass;\n    $scope.$activeClass = self.$options.activeClass;\n    self.$panes = $scope.$panes = [];\n    self.$activePaneChangeListeners = self.$viewChangeListeners = [];\n    self.$push = function(pane) {\n      if (angular.isUndefined(self.$panes.$active)) {\n        $scope.$setActive(pane.name || 0);\n      }\n      self.$panes.push(pane);\n    };\n    self.$remove = function(pane) {\n      var index = self.$panes.indexOf(pane);\n      var active = self.$panes.$active;\n      var activeIndex;\n      if (angular.isString(active)) {\n        activeIndex = self.$panes.map(function(pane) {\n          return pane.name;\n        }).indexOf(active);\n      } else {\n        activeIndex = self.$panes.$active;\n      }\n      self.$panes.splice(index, 1);\n      if (index < activeIndex) {\n        activeIndex--;\n      } else if (index === activeIndex && activeIndex === self.$panes.length) {\n        activeIndex--;\n      }\n      if (activeIndex >= 0 && activeIndex < self.$panes.length) {\n        self.$setActive(self.$panes[activeIndex].name || activeIndex);\n      } else {\n        self.$setActive();\n      }\n    };\n    self.$setActive = $scope.$setActive = function(value) {\n      self.$panes.$active = value;\n      self.$activePaneChangeListeners.forEach(function(fn) {\n        fn();\n      });\n    };\n    self.$isActive = $scope.$isActive = function($pane, $index) {\n      return self.$panes.$active === $pane.name || self.$panes.$active === $index;\n    };\n  };\n  this.$get = function() {\n    var $tab = {};\n    $tab.defaults = defaults;\n    $tab.controller = controller;\n    return $tab;\n  };\n}).directive('bsTabs', [ '$window', '$animate', '$tab', '$parse', function($window, $animate, $tab, $parse) {\n  var defaults = $tab.defaults;\n  return {\n    require: [ '?ngModel', 'bsTabs' ],\n    transclude: true,\n    scope: true,\n    controller: [ '$scope', '$element', '$attrs', $tab.controller ],\n    templateUrl: function(element, attr) {\n      return attr.template || defaults.template;\n    },\n    link: function postLink(scope, element, attrs, controllers) {\n      var ngModelCtrl = controllers[0];\n      var bsTabsCtrl = controllers[1];\n      if (ngModelCtrl) {\n        bsTabsCtrl.$activePaneChangeListeners.push(function() {\n          ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\n        });\n        ngModelCtrl.$formatters.push(function(modelValue) {\n          bsTabsCtrl.$setActive(modelValue);\n          return modelValue;\n        });\n      }\n      if (attrs.bsActivePane) {\n        var parsedBsActivePane = $parse(attrs.bsActivePane);\n        bsTabsCtrl.$activePaneChangeListeners.push(function() {\n          parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\n        });\n        scope.$watch(attrs.bsActivePane, function(newValue, oldValue) {\n          bsTabsCtrl.$setActive(newValue);\n        }, true);\n      }\n    }\n  };\n} ]).directive('bsPane', [ '$window', '$animate', '$sce', function($window, $animate, $sce) {\n  return {\n    require: [ '^?ngModel', '^bsTabs' ],\n    scope: true,\n    link: function postLink(scope, element, attrs, controllers) {\n      var bsTabsCtrl = controllers[1];\n      element.addClass('tab-pane');\n      attrs.$observe('title', function(newValue, oldValue) {\n        scope.title = $sce.trustAsHtml(newValue);\n      });\n      scope.name = attrs.name;\n      scope.link = attrs.link ? attrs.link : false;\n      if (bsTabsCtrl.$options.animation) {\n        element.addClass(bsTabsCtrl.$options.animation);\n      }\n      attrs.$observe('disabled', function(newValue, oldValue) {\n        scope.disabled = scope.$eval(newValue);\n      });\n      bsTabsCtrl.$push(scope);\n      scope.$on('$destroy', function() {\n        bsTabsCtrl.$remove(scope);\n      });\n      function render() {\n        var index = bsTabsCtrl.$panes.indexOf(scope);\n        $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\n      }\n      bsTabsCtrl.$activePaneChangeListeners.push(function() {\n        render();\n      });\n      render();\n    }\n  };\n} ]);\n\n// Source: popover/popover.js\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$popover', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      // uncommenting the next two lines will break backwards compatability\n      // prefixClass: 'popover',\n      // prefixEvent: 'popover',\n      container: false,\n      target: false,\n      placement: 'right',\n      templateUrl: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0,\n      autoClose: false\n    };\n\n    this.$get = function ($tooltip) {\n\n      function PopoverFactory (element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if (options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    };\n\n  })\n\n  .directive('bsPopover', function ($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr) {\n\n        var popover;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent', 'bsEnabled'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoClose'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n              if (angular.isDefined(oldValue)) {\n                requestAnimationFrame(function () {\n                  if (popover) popover.$applyPlacement();\n                });\n              }\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsPopover) {\n          scope.$watch(attr.bsPopover, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              requestAnimationFrame(function () {\n                if (popover) popover.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n            if (newValue === true) {\n              popover.show();\n            } else {\n              popover.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(popover),?/i);\n            if (newValue === false) {\n              popover.setEnabled(false);\n            } else {\n              popover.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            popover.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: select/select.js\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$select', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'select',\n      prefixEvent: '$select',\n      placement: 'bottom-left',\n      templateUrl: 'select/select.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      multiple: false,\n      allNoneButtons: false,\n      sort: true,\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\n      placeholder: 'Choose among the following...',\n      allText: 'All',\n      noneText: 'None',\n      maxLength: 3,\n      maxLengthHtml: 'selected',\n      iconCheckmark: 'glyphicon glyphicon-ok',\n      toggle: false\n    };\n\n    this.$get = function ($window, $document, $rootScope, $tooltip, $timeout) {\n\n      // var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n\n      function SelectFactory (element, controller, config) {\n\n        var $select = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $select = $tooltip(element, options);\n        var scope = $select.$scope;\n\n        scope.$matches = [];\n        if (options.multiple) {\n          scope.$activeIndex = [];\n        } else {\n          scope.$activeIndex = -1;\n        }\n        scope.$isMultiple = options.multiple;\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\n        scope.$iconCheckmark = options.iconCheckmark;\n        scope.$allText = options.allText;\n        scope.$noneText = options.noneText;\n\n        scope.$activate = function (index) {\n          scope.$$postDigest(function () {\n            $select.activate(index);\n          });\n        };\n\n        scope.$select = function (index, evt) {\n          scope.$$postDigest(function () {\n            $select.select(index);\n          });\n        };\n\n        scope.$isVisible = function () {\n          return $select.$isVisible();\n        };\n\n        scope.$isActive = function (index) {\n          return $select.$isActive(index);\n        };\n\n        scope.$selectAll = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (!scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        scope.$selectNone = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        // Public methods\n\n        $select.update = function (matches) {\n          scope.$matches = matches;\n          $select.$updateActiveIndex();\n        };\n\n        $select.activate = function (index) {\n          if (options.multiple) {\n            if ($select.$isActive(index)) {\n              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);\n            } else {\n              scope.$activeIndex.push(index);\n            }\n            if (options.sort) scope.$activeIndex.sort(function (a, b) { return a - b; }); // use numeric sort instead of default sort\n          } else {\n            scope.$activeIndex = index;\n          }\n          return scope.$activeIndex;\n        };\n\n        $select.select = function (index) {\n          if (angular.isUndefined(index) || index < 0 || index >= scope.$matches.length) { return; }\n          var value = scope.$matches[index].value;\n          scope.$apply(function () {\n            $select.activate(index);\n            if (options.multiple) {\n              controller.$setViewValue(scope.$activeIndex.map(function (index) {\n                if (angular.isUndefined(scope.$matches[index])) {\n                  return null;\n                }\n                return scope.$matches[index].value;\n              }));\n            } else {\n              if (options.toggle) {\n                controller.$setViewValue((value === controller.$modelValue) ? undefined : value);\n              } else {\n                controller.$setViewValue(value);\n              }\n              // Hide if single select\n              $select.hide();\n            }\n          });\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\n            options.onSelect(value, index, $select);\n          }\n        };\n\n        // Protected methods\n\n        $select.$updateActiveIndex = function () {\n          if (options.multiple) {\n            if (angular.isArray(controller.$modelValue)) {\n              scope.$activeIndex = controller.$modelValue.map(function (value) {\n                return $select.$getIndex(value);\n              });\n            } else {\n              scope.$activeIndex = [];\n            }\n          } else {\n            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\n            } else {\n              scope.$activeIndex = -1;\n            }\n          }\n        };\n\n        $select.$isVisible = function () {\n          if (!options.minLength || !controller) {\n            return scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\n        };\n\n        $select.$isActive = function (index) {\n          if (options.multiple) {\n            return scope.$activeIndex.indexOf(index) !== -1;\n          }\n          return scope.$activeIndex === index;\n        };\n\n        $select.$getIndex = function (value) {\n          var index;\n          for (index = scope.$matches.length; index--;) {\n            if (angular.equals(scope.$matches[index].value, value)) break;\n          }\n          return index;\n        };\n\n        $select.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            var anchor;\n\n            if (evt.target.nodeName !== 'A') {\n              var anchorCandidate = targetEl.parent();\n              while (!anchor && anchorCandidate.length > 0) {\n                if (anchorCandidate[0].nodeName === 'A') {\n                  anchor = anchorCandidate;\n                }\n                anchorCandidate = anchorCandidate.parent();\n              }\n            }\n\n            if (anchor) {\n              angular.element(anchor).triggerHandler('click');\n            } else {\n              targetEl.triggerHandler('click');\n            }\n          }\n        };\n\n        $select.$onKeyDown = function (evt) {\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\n          // Let tab propagate\n          if (evt.keyCode !== 9) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // release focus on tab\n          if (options.multiple && evt.keyCode === 9) {\n            return $select.hide();\n          }\n\n          // Select with enter\n          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\n            return $select.select(scope.$activeIndex);\n          }\n\n          if (!options.multiple) {\n            // Navigate with keyboard\n            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n            else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\n            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n            scope.$digest();\n          }\n        };\n\n        $select.$isIE = function () {\n          var ua = $window.navigator.userAgent;\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\n        };\n\n        $select.$selectScrollFix = function (e) {\n          if ($document[0].activeElement.tagName === 'UL') {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            e.target.focus();\n          }\n        };\n\n        // Overrides\n\n        var _show = $select.show;\n        $select.show = function () {\n          _show();\n          if (options.multiple) {\n            $select.$element.addClass('select-multiple');\n          }\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $select.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $select.hide;\n        $select.hide = function () {\n          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {\n            scope.$activeIndex = -1;\n          }\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $select.$onKeyDown);\n          }\n          _hide(true);\n        };\n\n        return $select;\n\n      }\n\n      SelectFactory.defaults = defaults;\n      return SelectFactory;\n\n    };\n\n  })\n\n  .directive('bsSelect', function ($window, $parse, $q, $select, $parseOptions) {\n\n    var defaults = $select.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, placeholder: defaults.placeholder};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent', 'toggle'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show, hide and select events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\n        var dataMultiple = element.attr('data-multiple');\n        if (angular.isDefined(dataMultiple)) {\n          if (falseValueRegExp.test(dataMultiple)) {\n            options.multiple = false;\n          } else {\n            options.multiple = dataMultiple;\n          }\n        }\n\n        // Add support for select markup\n        if (element[0].nodeName.toLowerCase() === 'select') {\n          var inputEl = element;\n          inputEl.css('display', 'none');\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\"></button>');\n          inputEl.after(element);\n        }\n\n        // Build proper bsOptions\n        var parsedOptions = $parseOptions(attr.bsOptions);\n\n        // Initialize select\n        var select = $select(element, controller, options);\n\n        if (select.$isIE()) {\n          element[0].addEventListener('blur', select.$selectScrollFix);\n        }\n\n        // Watch bsOptions values before filtering for changes\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\n        scope.$watch(watchedOptions, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n          parsedOptions.valuesFn(scope, controller)\n          .then(function (values) {\n            select.update(values);\n            controller.$render();\n          });\n        }, true);\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\n          select.$updateActiveIndex();\n          controller.$render();\n        }, true);\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var selected;\n          var index;\n          if (options.multiple && angular.isArray(controller.$modelValue)) {\n            selected = controller.$modelValue.map(function (value) {\n              index = select.$getIndex(value);\n              return index !== -1 ? select.$scope.$matches[index].label : false;\n            }).filter(angular.isDefined);\n            if (selected.length > (options.maxLength || defaults.maxLength)) {\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\n            } else {\n              selected = selected.join(', ');\n            }\n          } else {\n            index = select.$getIndex(controller.$modelValue);\n            selected = index !== -1 ? select.$scope.$matches[index].label : false;\n          }\n          element.html((selected || options.placeholder) + (options.caretHtml || defaults.caretHtml));\n        };\n\n        if (options.multiple) {\n          controller.$isEmpty = function (value) {\n            return !value || value.length === 0;\n          };\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (select) select.destroy();\n          options = null;\n          select = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: pagination/pagination.js\n// 1, 2, 3 ... 10\n// 1 ... 8, 9, 10\n// 1 ... 5, 6, 7 ... 10\nangular.module('mgcrea.ngStrap.pagination', [])\n  .provider('$pagination', function() {\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      pageClass: 'pagination',\n      pagesLength: 5,\n      itemsPerPage: 20,\n      templateUrl: 'pagination/pagination.tpl.html'\n    };\n\n    var controller = this.controller = function($scope, $element, $attrs) {\n      /**\n       * \n       * @returns {number}\n       */\n      this.calculateTotalPages = function(itemsPerPage, totalItems) {\n        var totalPages = itemsPerPage < 1\n          ? 1\n          : Math.ceil(totalItems / itemsPerPage);\n        return Math.max(totalPages || 0, 1);\n      };\n\n      this.makePage = function (number, text, isActive) {\n        return {\n          number: number,\n          text: text,\n          active: isActive\n        };\n      };\n\n      /**\n       * \n       * @param currentPage \n       * @param totalPages  \n       * @param pagesLength \n       * @returns {Array}\n       */\n      this.getPages = function (currentPage, totalPages, pagesLength) {\n        // \n        currentPage = currentPage < 1\n          ? 1\n          : ((totalPages > 0 && currentPage > totalPages) ? totalPages : currentPage);\n\n        var pages = [];\n        var i;\n\n        if (totalPages <= pagesLength) {\n          for (i = 1; i <= totalPages; i++){\n            pages.push(this.makePage(i, i, i === currentPage));\n          }\n        }\n        else { // 1....2....3....\n          // \n          var offset = (pagesLength - 1) / 2;\n          if (currentPage <= offset) {\n            // ...\n            for (i = 1; i <= offset + 1; i++){\n              pages.push(this.makePage(i, i, i === currentPage));\n            }\n            pages.push(this.makePage(i + 1, '...', false));\n            pages.push(this.makePage(totalPages, totalPages, false));\n          }\n          else if (currentPage > totalPages - offset) {\n            pages.push(this.makePage(1, 1, false));\n            pages.push(this.makePage(totalPages - offset - 1, '...', false));\n            for(i = offset; i >= 0; i--){\n              var p = totalPages - i;\n              pages.push(this.makePage(p, p, p === currentPage));\n            }\n          }\n          else {\n            // ...\n            pages.push(this.makePage(1, 1, false));\n            // \n            var half = Math.ceil(offset / 2);\n            pages.push(this.makePage(currentPage - half - 1, '...', false));\n            for(i = half; i >= 1; i--){\n              pages.push(this.makePage(currentPage - i, currentPage - i, false));\n            }\n            pages.push(this.makePage(currentPage, currentPage, true));\n            for(i = 1; i <= half; i++){\n              pages.push(this.makePage(currentPage + i, currentPage + i, false));\n            }\n            pages.push(this.makePage(currentPage + half + 1, '...', false));\n            pages.push(this.makePage(totalPages, totalPages, false));\n          }\n        }\n        return pages;\n      };\n    };\n    this.$get = function() {\n      var $pagination = {};\n      $pagination.defaults = defaults;\n      $pagination.controller = controller;\n      return $pagination;\n    };\n  })\n  .directive('bsPagination', [ '$window', '$sce', '$parse', '$pagination', function($window, $sce, $parse, $pagination) {\n    var defaults = $pagination.defaults;\n    return {\n      restrict: 'E',\n      require: [ '?ngModel', 'bsPagination' ],\n      scope: true,\n      replace: true,\n      controller: ['$scope', '$element', '$attrs', $pagination.controller],\n      templateUrl: function (element, attr) {\n        return attr.template || defaults.templateUrl;\n      },\n      link: function postLink(scope, element, attrs, controllers) {\n        var ngModelCtrl = controllers[0];\n        var bsPaginationCtrl = controllers[1];\n\n        if (!ngModelCtrl) {\n          return;\n        }\n\n        var options = angular.copy(defaults);\n\n        // \n        angular.forEach(['pageClass', 'pagesLength', 'itemsPerPage'], function (key) {\n          if (angular.isDefined(attrs[key])) {\n            options[key] = scope.$eval(attrs[key]);\n          }\n        });\n        angular.forEach(['onChange'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attrs[bsKey])) {\n            options[key] = scope.$eval(attrs[bsKey]);\n          }\n        });\n        // totalItemsloadingno result\n        if (attrs['totalItems']) {\n          attrs.$observe('totalItems', function (newValue, oldValue) {\n            scope.totalItems = newValue;\n            scope.totalPages = bsPaginationCtrl.calculateTotalPages(options.itemsPerPage, scope.totalItems);\n            ngModelCtrl.$render();\n          });\n        }\n\n        scope.$pageClass = options.pageClass;\n        // pageLength\n        if (options.pagesLength % 2 === 0) {\n          options.pagesLength = options.pagesLength + 1;\n        }\n\n        /**\n         * modelpage\n         */\n        ngModelCtrl.$render = function () {\n          scope.page = (parseInt(ngModelCtrl.$viewValue, 10) || 1) > scope.totalPages ? scope.totalPages : scope.page;\n          if (scope.page > 0 && scope.page <= scope.totalPages) {\n            scope.pages = bsPaginationCtrl.getPages(scope.page, scope.totalPages, options.pagesLength);\n          }\n        };\n\n        /**\n         * \n         * @param page\n         * @param evt\n         */\n        scope.selectPage = function (page, evt) {\n          if (evt) {\n            evt.preventDefault();\n          }\n          if (scope.page !== page && page > 0 && page <= scope.totalPages) {\n            if (evt && evt.target) {\n              evt.target.blur();\n            }\n            // \n            ngModelCtrl.$setViewValue(page);\n            ngModelCtrl.$render();\n\n            if (angular.isDefined(options.onChange) && angular.isFunction(options.onChange)) {\n              // observe\n              options.onChange();\n            }\n          }\n        };\n\n        scope.noPrevious = function () {\n          return scope.page === 1;\n        };\n\n        scope.noNext = function () {\n          return scope.page === scope.totalPages;\n        };\n\n        scope.selectPrevious = function (evt) {\n          scope.selectPage(scope.page - 1, evt);\n        };\n\n        scope.selectNext = function (evt) {\n          scope.selectPage(scope.page + 1, evt);\n        };\n      }\n    };\n  }]);\n\n// Source: helpers/raf.js\nif (angular.version.minor < 3 && angular.version.dot < 14) {\n  angular.module('ng')\n\n  .factory('$$rAF', function ($window, $timeout) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame ||\n                                $window.webkitRequestAnimationFrame ||\n                                $window.mozRequestAnimationFrame;\n\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                               $window.webkitCancelAnimationFrame ||\n                               $window.mozCancelAnimationFrame ||\n                               $window.webkitCancelRequestAnimationFrame;\n\n    var rafSupported = !!requestAnimationFrame;\n    var raf = rafSupported ?\n      function (fn) {\n        var id = requestAnimationFrame(fn);\n        return function () {\n          cancelAnimationFrame(id);\n        };\n      } :\n      function (fn) {\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n        return function () {\n          $timeout.cancel(timer);\n        };\n      };\n\n    raf.supported = rafSupported;\n\n    return raf;\n\n  });\n}\n\n// Source: helpers/parse-options.js\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function () {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function ($parse, $q) {\n\n      function ParseOptionsFactory (attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match;\n        var displayFn;\n        var valueName;\n        /* eslint-disable no-unused-vars */\n        var keyName;\n        var groupByFn;\n        /* eslint-enable no-unused-vars */\n        var valueFn;\n        var valuesFn;\n\n        $parseOptions.init = function () {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]);\n          valueName = match[4] || match[6];\n          keyName = match[5];\n          groupByFn = $parse(match[3] || '');\n          valueFn = $parse(match[2] ? match[1] : valueName);\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function (scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function (values) {\n            if (!angular.isArray(values)) {\n              values = [];\n            }\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function (modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues (values, scope) {\n          return values.map(function (match, index) {\n            var locals = {};\n            var label;\n            var value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n\n// Source: helpers/dimensions.js\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function () {\n\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function (element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function (element, prop, extra) {\n      var value;\n      if (element.currentStyle) { // IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function (element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n\n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition;\n      var curLeft;\n      var curCSSTop;\n      var curTop;\n      var curOffset;\n      var curCSSLeft;\n      var calculatePosition;\n      var position = fn.css(element, 'position');\n      var curElem = angular.element(element);\n      var props = {};\n\n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n\n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n\n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n\n      if (options.top !== null) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if (options.left !== null) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function (element) {\n\n      var offsetParentRect = {top: 0, left: 0};\n      var offsetParentEl;\n      var offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentEl\n        offsetParentEl = offsetParentElement(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentEl, 'html')) {\n          offsetParentRect = fn.offset(offsetParentEl);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    function offsetParentElement (element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    }\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function (element, outer) {\n      var value = element.offsetHeight;\n      if (outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function (element, outer) {\n      var value = element.offsetWidth;\n      if (outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n\n// Source: helpers/debounce.js\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function ($timeout) {\n  return function (func, wait, immediate) {\n    var timeout = null;\n    return function () {\n      var context = this;\n      var args = arguments;\n      var callNow = immediate && !timeout;\n      if (timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later () {\n        timeout = null;\n        if (!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if (callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function ($timeout) {\n  return function (func, wait, options) {\n    var timeout = null;\n    if (!options) options = {};\n    return function () {\n      var context = this;\n      var args = arguments;\n      if (!timeout) {\n        if (options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later () {\n          timeout = null;\n          if (options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n\n// Source: helpers/date-parser.js\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function ($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate () {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\n  ParseDate.prototype.getHours = function () { return this.hours; };\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\n  ParseDate.prototype.fromDate = function (value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function () {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop () {\n  }\n\n  function isNumeric (n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive (array, value) {\n    var len = array.length;\n    var str = value.toString().toLowerCase();\n    for (var i = 0; i < len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function ($locale, dateFilter) {\n\n    var DateParserFactory = function (config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      /* eslint-disable key-spacing, quote-props */\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\n      };\n      /* eslint-enable key-spacing, quote-props */\n\n      var regex;\n      var setMap;\n\n      $dateParser.init = function () {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function (date) {\n        if (angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function (value, baseDate, format, timezone) {\n        // check for date format special names\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if (!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for (var i = 0; i < matches.length - 1; i++) {\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function (key, value) {\n        var date;\n\n        if (value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if (isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function (key, value) {\n        var time;\n\n        if (value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if (isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function (date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function regExpForFormat (format) {\n        // `format` string can contain literal values.\n        // These need to be escaped by surrounding with\n        // single quotes (e.g. `\"h 'in the morning'\"`).\n        // In order to output a single quote, escape it - i.e.,\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\n\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseRegex(re);\n      }\n\n      function buildDateAbstractRegex (format) {\n        var escapedFormat = escapeReservedSymbols(format);\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\n        var literalRegex = /('(?:\\\\'|.)*?')/;\n        var formatParts = escapedLiteralFormat.split(literalRegex);\n        var dateElements = Object.keys(regExpMap);\n        var dateRegexParts = [];\n\n        angular.forEach(formatParts, function (part) {\n          if (isFormatStringLiteral(part)) {\n            part = trimLiteralEscapeChars(part);\n          } else {\n            // Abstract replaces to avoid collisions\n            for (var i = 0; i < dateElements.length; i++) {\n              part = part.split(dateElements[i]).join('${' + i + '}');\n            }\n          }\n          dateRegexParts.push(part);\n        });\n\n        return dateRegexParts.join('');\n      }\n\n      function escapeReservedSymbols (text) {\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\n                   .replace(/-/g, '[-]')\n                   .replace(/\\./g, '[.]')\n                   .replace(/\\*/g, '[*]')\n                   .replace(/\\+/g, '[+]')\n                   .replace(/\\?/g, '[?]')\n                   .replace(/\\$/g, '[$]')\n                   .replace(/\\^/g, '[^]')\n                   .replace(/\\//g, '[/]')\n                   .replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function isFormatStringLiteral (text) {\n        return /^'.*'$/.test(text);\n      }\n\n      function trimLiteralEscapeChars (text) {\n        return text.replace(/^'(.*)'$/, '$1');\n      }\n\n      function buildDateParseRegex (abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var re = abstractRegex;\n\n        // Replace abstracted values\n        for (var i = 0; i < dateElements.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\n        }\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      function setMapForFormat (format) {\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseValuesMap(re);\n      }\n\n      function buildDateParseValuesMap (abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\n        var valuesMatch;\n        var keyIndex;\n        var valueKey;\n        var valueFunction;\n        var valuesFunctionMap = [];\n\n        /* eslint-disable no-cond-assign */\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\n          keyIndex = valuesMatch[1];\n          valueKey = dateElements[keyIndex];\n          valueFunction = setFnMap[valueKey];\n\n          valuesFunctionMap.push(valueFunction);\n        }\n\n        return valuesFunctionMap;\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n\n// Source: helpers/date-formatter.js\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function ($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function () {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function (format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function (lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat (format) {\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm:ss a => ss\n    this.secondsFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm:ss a => true, h:mm a => false\n    this.showSeconds = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[5];\n    };\n\n    this.formatDate = function (date, format, lang, timezone) {\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n\n// Source: helpers/compiler.js\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\n\nangular.module('mgcrea.ngStrap.core', [])\n  .service('$bsCompiler', bsCompilerService);\n\nfunction bsCompilerService ($q, $http, $injector, $compile, $controller, $templateCache) {\n\n  /*\n   * @ngdoc service\n   * @name $bsCompiler\n   * @module material.core\n   * @description\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $bsCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $bsCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is\n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties:\n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function (options) {\n\n    if (options.template && /\\.html$/.test(options.template)) {\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\n      options.templateUrl = options.template;\n      options.template = '';\n    }\n\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = angular.copy(options.resolve || {});\n    var locals = angular.copy(options.locals || {});\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function (value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    // Add the locals, which are just straight values to inject\n    // eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (template) {\n      resolve.$template = $q.when(template);\n    } else if (templateUrl) {\n      resolve.$template = fetchTemplate(templateUrl);\n    } else {\n      throw new Error('Missing `template` / `templateUrl` option.');\n    }\n\n    if (options.titleTemplate) {\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          findElement('[ng-bind=\"title\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    if (options.contentTemplate) {\n      // TODO(mgcrea): deprecate?\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n          if (!options.templateUrl) contentEl.next().remove();\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function (locals) {\n\n      var template = transformTemplate(locals.$template);\n      if (options.html) {\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\n      }\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var element = angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      // Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link (scope) {\n          locals.$scope = scope;\n\n          // Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            // Support angular@~1.2 invokeCtrl\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\n            // See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n\n          return linkFn.apply(null, arguments);\n        }\n      };\n    });\n\n  };\n\n  function findElement (query, element) {\n    return angular.element((element || document).querySelectorAll(query));\n  }\n\n  var fetchPromises = {};\n  function fetchTemplate (template) {\n    if (fetchPromises[template]) return fetchPromises[template];\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\n      .then(function (res) {\n        return res.data;\n      }));\n  }\n\n}\n\n// Source: datepicker/datepicker.js\nangular.module('mgcrea.ngStrap.datepicker', [ 'mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip' ]).provider('$datepicker', function() {\n  var defaults = this.defaults = {\n    animation: 'am-fade',\n    prefixClass: 'datepicker',\n    placement: 'bottom-left',\n    templateUrl: 'datepicker/datepicker.tpl.html',\n    trigger: 'focus',\n    container: false,\n    keyboard: true,\n    html: false,\n    delay: 0,\n    useNative: false,\n    dateType: 'date',\n    dateFormat: 'shortDate',\n    timezone: null,\n    modelDateFormat: null,\n    dayFormat: 'dd',\n    monthFormat: 'MMM',\n    yearFormat: 'yyyy',\n    monthTitleFormat: 'MMMM yyyy',\n    yearTitleFormat: 'yyyy',\n    strictFormat: false,\n    autoclose: false,\n    minDate: -Infinity,\n    maxDate: +Infinity,\n    startView: 0,\n    minView: 0,\n    startWeek: 0,\n    daysOfWeekDisabled: '',\n    hasToday: false,\n    hasClear: false,\n    iconLeft: 'nox-sort-left',\n    iconRight: 'nox-sort-right'\n  };\n  this.$get = [ '$window', '$document', '$rootScope', '$sce', '$dateFormatter', 'datepickerViews', '$tooltip', '$timeout', function($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n    var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);\n    var isTouch = 'createTouch' in $window.document && isNative;\n    if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n    function DatepickerFactory(element, controller, config) {\n      var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n      var parentScope = config.scope;\n      var options = $datepicker.$options;\n      var scope = $datepicker.$scope;\n      if (options.startView) options.startView -= options.minView;\n      var pickerViews = datepickerViews($datepicker);\n      $datepicker.$views = pickerViews.views;\n      var viewDate = pickerViews.viewDate;\n      scope.$mode = options.startView;\n      scope.$iconLeft = options.iconLeft;\n      scope.$iconRight = options.iconRight;\n      scope.$hasToday = options.hasToday;\n      scope.$hasClear = options.hasClear;\n      var $picker = $datepicker.$views[scope.$mode];\n      scope.$select = function(date) {\n        $datepicker.select(date);\n      };\n      scope.$selectPane = function(value) {\n        $datepicker.$selectPane(value);\n      };\n      scope.$toggleMode = function() {\n        $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n      };\n      scope.$setToday = function() {\n        if (options.autoclose) {\n          $datepicker.setMode(0);\n          $datepicker.select(new Date());\n        } else {\n          $datepicker.select(new Date(), true);\n        }\n      };\n      scope.$clear = function() {\n        if (options.autoclose) {\n          $datepicker.setMode(0);\n          $datepicker.select(null);\n        } else {\n          $datepicker.select(null, true);\n        }\n      };\n      $datepicker.update = function(date) {\n        if (angular.isDate(date) && !isNaN(date.getTime())) {\n          $datepicker.$date = date;\n          $picker.update.call($picker, date);\n        }\n        $datepicker.$build(true);\n      };\n      $datepicker.updateDisabledDates = function(dateRanges) {\n        options.disabledDateRanges = dateRanges;\n        for (var i = 0, l = scope.rows.length; i < l; i++) {\n          angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n        }\n      };\n      $datepicker.select = function(date, keep) {\n        if (angular.isDate(date)) {\n          if (!angular.isDate(controller.$dateValue) || isNaN(controller.$dateValue.getTime())) {\n            controller.$dateValue = new Date(date);\n          }\n        } else {\n          controller.$dateValue = null;\n        }\n        if (!scope.$mode || keep) {\n          controller.$setViewValue(angular.copy(date));\n          controller.$render();\n          if (options.autoclose && !keep) {\n            $timeout(function() {\n              $datepicker.hide(true);\n            });\n          }\n        } else {\n          angular.extend(viewDate, {\n            year: date.getFullYear(),\n            month: date.getMonth(),\n            date: date.getDate()\n          });\n          $datepicker.setMode(scope.$mode - 1);\n          $datepicker.$build();\n        }\n      };\n      $datepicker.setMode = function(mode) {\n        scope.$mode = mode;\n        $picker = $datepicker.$views[scope.$mode];\n        $datepicker.$build();\n      };\n      $datepicker.$build = function(pristine) {\n        if (pristine === true && $picker.built) return;\n        if (pristine === false && !$picker.built) return;\n        $picker.build.call($picker);\n      };\n      $datepicker.$updateSelected = function() {\n        for (var i = 0, l = scope.rows.length; i < l; i++) {\n          angular.forEach(scope.rows[i], updateSelected);\n        }\n      };\n      $datepicker.$isSelected = function(date) {\n        return $picker.isSelected(date);\n      };\n      $datepicker.$setDisabledEl = function(el) {\n        el.disabled = $picker.isDisabled(el.date);\n      };\n      $datepicker.$selectPane = function(value) {\n        var steps = $picker.steps;\n        var targetDate = new Date(Date.UTC(viewDate.year + (steps.year || 0) * value, viewDate.month + (steps.month || 0) * value, 1));\n        angular.extend(viewDate, {\n          year: targetDate.getUTCFullYear(),\n          month: targetDate.getUTCMonth(),\n          date: targetDate.getUTCDate()\n        });\n        $datepicker.$build();\n      };\n      $datepicker.$onMouseDown = function(evt) {\n        evt.preventDefault();\n        evt.stopPropagation();\n        if (isTouch) {\n          var targetEl = angular.element(evt.target);\n          if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n            targetEl = targetEl.parent();\n          }\n          targetEl.triggerHandler('click');\n        }\n      };\n      $datepicker.$onKeyDown = function(evt) {\n        if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n        evt.preventDefault();\n        evt.stopPropagation();\n        if (evt.keyCode === 13) {\n          if (!scope.$mode) {\n            $datepicker.hide(true);\n          } else {\n            scope.$apply(function() {\n              $datepicker.setMode(scope.$mode - 1);\n            });\n          }\n          return;\n        }\n        $picker.onKeyDown(evt);\n        parentScope.$digest();\n      };\n      function updateSelected(el) {\n        el.selected = $datepicker.$isSelected(el.date);\n      }\n      function focusElement() {\n        element[0].focus();\n      }\n      var _init = $datepicker.init;\n      $datepicker.init = function() {\n        if (isNative && options.useNative) {\n          element.prop('type', 'date');\n          element.css('-webkit-appearance', 'textfield');\n          return;\n        } else if (isTouch) {\n          element.prop('type', 'text');\n          element.attr('readonly', 'true');\n          element.on('click', focusElement);\n        }\n        _init();\n      };\n      var _destroy = $datepicker.destroy;\n      $datepicker.destroy = function() {\n        if (isNative && options.useNative) {\n          element.off('click', focusElement);\n        }\n        _destroy();\n      };\n      var _show = $datepicker.show;\n      $datepicker.show = function() {\n        if (!isTouch && element.attr('readonly') || element.attr('disabled')) return;\n        _show();\n        $timeout(function() {\n          if (!$datepicker.$isShown) return;\n          $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if (options.keyboard) {\n            element.on('keydown', $datepicker.$onKeyDown);\n          }\n        }, 0, false);\n      };\n      var _hide = $datepicker.hide;\n      $datepicker.hide = function(blur) {\n        if (!$datepicker.$isShown) return;\n        $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n        if (options.keyboard) {\n          element.off('keydown', $datepicker.$onKeyDown);\n        }\n        _hide(blur);\n      };\n      return $datepicker;\n    }\n    DatepickerFactory.defaults = defaults;\n    return DatepickerFactory;\n  } ];\n}).directive('bsDatepicker', [ '$window', '$parse', '$q', '$dateFormatter', '$dateParser', '$datepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n  var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);\n  return {\n    restrict: 'EAC',\n    require: 'ngModel',\n    link: function postLink(scope, element, attr, controller) {\n      var options = {\n        scope: scope\n      };\n      angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent', 'hasToday', 'hasClear' ], function(key) {\n        if (angular.isDefined(attr[key])) options[key] = attr[key];\n      });\n      var falseValueRegExp = /^(false|0|)$/i;\n      angular.forEach([ 'html', 'container', 'autoclose', 'useNative', 'hasToday', 'hasClear' ], function(key) {\n        if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n          options[key] = false;\n        }\n      });\n      angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide' ], function(key) {\n        var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n        if (angular.isDefined(attr[bsKey])) {\n          options[key] = scope.$eval(attr[bsKey]);\n        }\n      });\n      var datepicker = $datepicker(element, controller, options);\n      options = datepicker.$options;\n      if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n      var lang = options.lang;\n      var formatDate = function(date, format) {\n        return $dateFormatter.formatDate(date, format, lang);\n      };\n      var dateParser = $dateParser({\n        format: options.dateFormat,\n        lang: lang,\n        strict: options.strictFormat\n      });\n      if (attr.bsShow) {\n        scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if (!datepicker || !angular.isDefined(newValue)) return;\n          if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n          if (newValue === true) {\n            datepicker.show();\n          } else {\n            datepicker.hide();\n          }\n        });\n      }\n      angular.forEach([ 'minDate', 'maxDate' ], function(key) {\n        if (angular.isDefined(attr[key])) {\n          attr.$observe(key, function(newValue) {\n            datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n            if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\n            validateAgainstMinMaxDate(controller.$dateValue);\n          });\n        }\n      });\n      if (angular.isDefined(attr.dateFormat)) {\n        attr.$observe('dateFormat', function(newValue) {\n          datepicker.$options.dateFormat = newValue;\n        });\n      }\n      scope.$watch(attr.ngModel, function(newValue, oldValue) {\n        datepicker.update(controller.$dateValue);\n      }, true);\n      function normalizeDateRanges(ranges) {\n        if (!ranges || !ranges.length) return null;\n        return ranges;\n      }\n      if (angular.isDefined(attr.disabledDates)) {\n        scope.$watch(attr.disabledDates, function(disabledRanges, previousValue) {\n          disabledRanges = normalizeDateRanges(disabledRanges);\n          previousValue = normalizeDateRanges(previousValue);\n          if (disabledRanges) {\n            datepicker.updateDisabledDates(disabledRanges);\n          }\n        });\n      }\n      function validateAgainstMinMaxDate(parsedDate) {\n        if (!angular.isDate(parsedDate)) return;\n        var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n        var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n        var isValid = isMinValid && isMaxValid;\n        controller.$setValidity('date', isValid);\n        controller.$setValidity('min', isMinValid);\n        controller.$setValidity('max', isMaxValid);\n        if (isValid) controller.$dateValue = parsedDate;\n      }\n      controller.$parsers.unshift(function(viewValue) {\n        var date;\n        if (!viewValue) {\n          controller.$setValidity('date', true);\n          return null;\n        }\n        var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n        if (!parsedDate || isNaN(parsedDate.getTime())) {\n          controller.$setValidity('date', false);\n          return;\n        }\n        validateAgainstMinMaxDate(parsedDate);\n        if (options.dateType === 'string') {\n          date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n          return formatDate(date, options.modelDateFormat || options.dateFormat);\n        }\n        date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n        if (options.dateType === 'number') {\n          return date.getTime();\n        } else if (options.dateType === 'unix') {\n          return date.getTime() / 1e3;\n        } else if (options.dateType === 'iso') {\n          return date.toISOString();\n        }\n        return new Date(date);\n      });\n      controller.$formatters.push(function(modelValue) {\n        var date;\n        if (angular.isUndefined(modelValue) || modelValue === null) {\n          date = NaN;\n        } else if (angular.isDate(modelValue)) {\n          date = modelValue;\n        } else if (options.dateType === 'string') {\n          date = dateParser.parse(modelValue, null, options.modelDateFormat);\n        } else if (options.dateType === 'unix') {\n          date = new Date(modelValue * 1e3);\n        } else {\n          date = new Date(modelValue);\n        }\n        controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n        return getDateFormattedString();\n      });\n      controller.$render = function() {\n        element.val(getDateFormattedString());\n      };\n      function getDateFormattedString() {\n        return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n      }\n      scope.$on('$destroy', function() {\n        if (datepicker) datepicker.destroy();\n        options = null;\n        datepicker = null;\n      });\n    }\n  };\n} ]).provider('datepickerViews', function() {\n  function split(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  }\n  function mod(n, m) {\n    return (n % m + m) % m;\n  }\n  this.$get = [ '$dateFormatter', '$dateParser', '$sce', function($dateFormatter, $dateParser, $sce) {\n    return function(picker) {\n      var scope = picker.$scope;\n      var options = picker.$options;\n      var lang = options.lang;\n      var formatDate = function(date, format) {\n        return $dateFormatter.formatDate(date, format, lang);\n      };\n      var dateParser = $dateParser({\n        format: options.dateFormat,\n        lang: lang,\n        strict: options.strictFormat\n      });\n      var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n      var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n      var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n      var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n      var viewDate = {\n        year: startDate.getFullYear(),\n        month: startDate.getMonth(),\n        date: startDate.getDate()\n      };\n      var views = [ {\n        format: options.dayFormat,\n        split: 7,\n        steps: {\n          month: 1\n        },\n        update: function(date, force) {\n          if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n            angular.extend(viewDate, {\n              year: picker.$date.getFullYear(),\n              month: picker.$date.getMonth(),\n              date: picker.$date.getDate()\n            });\n            picker.$build();\n          } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\n            viewDate.date = picker.$date.getDate();\n            picker.$updateSelected();\n          }\n        },\n        build: function() {\n          var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\n          var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n          var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\n          var firstDateOffset = firstDate.getTimezoneOffset();\n          var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n          if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 6e4);\n          var days = [];\n          var day;\n          for (var i = 0; i < 42; i++) {\n            day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n            days.push({\n              date: day,\n              isToday: day.toDateString() === today,\n              label: formatDate(day, this.format),\n              selected: picker.$date && this.isSelected(day),\n              muted: day.getMonth() !== viewDate.month,\n              disabled: this.isDisabled(day)\n            });\n          }\n          scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n          scope.showLabels = true;\n          scope.labels = weekDaysLabelsHtml;\n          scope.rows = split(days, this.split);\n          scope.isTodayDisabled = this.isDisabled(new Date());\n          this.built = true;\n        },\n        isSelected: function(date) {\n          return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n        },\n        isDisabled: function(date) {\n          var time = date.getTime();\n          if (time < Date.parse(options.minDate) || time > Date.parse(options.maxDate)) return true;\n          if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n          if (options.disabledDateRanges) {\n            for (var i = 0; i < options.disabledDateRanges.length; i++) {\n              if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                return true;\n              }\n            }\n          }\n          return false;\n        },\n        onKeyDown: function(evt) {\n          if (!picker.$date) {\n            return;\n          }\n          var actualTime = picker.$date.getTime();\n          var newDate;\n          if (evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5); else if (evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5); else if (evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5); else if (evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n          if (!this.isDisabled(newDate)) picker.select(newDate, true);\n        }\n      }, {\n        name: 'month',\n        format: options.monthFormat,\n        split: 4,\n        steps: {\n          year: 1\n        },\n        update: function(date, force) {\n          if (!this.built || date.getFullYear() !== viewDate.year) {\n            angular.extend(viewDate, {\n              year: picker.$date.getFullYear(),\n              month: picker.$date.getMonth(),\n              date: picker.$date.getDate()\n            });\n            picker.$build();\n          } else if (date.getMonth() !== viewDate.month) {\n            angular.extend(viewDate, {\n              month: picker.$date.getMonth(),\n              date: picker.$date.getDate()\n            });\n            picker.$updateSelected();\n          }\n        },\n        build: function() {\n          var months = [];\n          var month;\n          for (var i = 0; i < 12; i++) {\n            month = new Date(viewDate.year, i, 1);\n            months.push({\n              date: month,\n              label: formatDate(month, this.format),\n              selected: picker.$isSelected(month),\n              disabled: this.isDisabled(month)\n            });\n          }\n          scope.title = formatDate(month, options.yearTitleFormat);\n          scope.showLabels = false;\n          scope.rows = split(months, this.split);\n          this.built = true;\n        },\n        isSelected: function(date) {\n          return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n        },\n        isDisabled: function(date) {\n          var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n          return lastDate < options.minDate || date.getTime() > options.maxDate;\n        },\n        onKeyDown: function(evt) {\n          if (!picker.$date) {\n            return;\n          }\n          var actualMonth = picker.$date.getMonth();\n          var newDate = new Date(picker.$date);\n          if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1); else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4); else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1); else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n          if (!this.isDisabled(newDate)) picker.select(newDate, true);\n        }\n      }, {\n        name: 'year',\n        format: options.yearFormat,\n        split: 4,\n        steps: {\n          year: 12\n        },\n        update: function(date, force) {\n          if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\n            angular.extend(viewDate, {\n              year: picker.$date.getFullYear(),\n              month: picker.$date.getMonth(),\n              date: picker.$date.getDate()\n            });\n            picker.$build();\n          } else if (date.getFullYear() !== viewDate.year) {\n            angular.extend(viewDate, {\n              year: picker.$date.getFullYear(),\n              month: picker.$date.getMonth(),\n              date: picker.$date.getDate()\n            });\n            picker.$updateSelected();\n          }\n        },\n        build: function() {\n          var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n          var years = [];\n          var year;\n          for (var i = 0; i < 12; i++) {\n            year = new Date(firstYear + i, 0, 1);\n            years.push({\n              date: year,\n              label: formatDate(year, this.format),\n              selected: picker.$isSelected(year),\n              disabled: this.isDisabled(year)\n            });\n          }\n          scope.title = years[0].label + '-' + years[years.length - 1].label;\n          scope.showLabels = false;\n          scope.rows = split(years, this.split);\n          this.built = true;\n        },\n        isSelected: function(date) {\n          return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n        },\n        isDisabled: function(date) {\n          var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n          return lastDate < options.minDate || date.getTime() > options.maxDate;\n        },\n        onKeyDown: function(evt) {\n          if (!picker.$date) {\n            return;\n          }\n          var actualYear = picker.$date.getFullYear();\n          var newDate = new Date(picker.$date);\n          if (evt.keyCode === 37) newDate.setYear(actualYear - 1); else if (evt.keyCode === 38) newDate.setYear(actualYear - 4); else if (evt.keyCode === 39) newDate.setYear(actualYear + 1); else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\n          if (!this.isDisabled(newDate)) picker.select(newDate, true);\n        }\n      } ];\n      return {\n        views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n        viewDate: viewDate\n      };\n    };\n  } ];\n});\n\n// Source: dropdown/dropdown.js\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$dropdown', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'dropdown',\n      prefixEvent: 'dropdown',\n      placement: 'bottom-left',\n      templateUrl: 'dropdown/dropdown.tpl.html',\n      trigger: 'click',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0\n    };\n\n    this.$get = function ($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\n      function DropdownFactory (element, config) {\n\n        var $dropdown = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        /* var scope = */$dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        $dropdown = $tooltip(element, options);\n        var parentEl = element.parent();\n\n        // Protected methods\n\n        $dropdown.$onKeyDown = function (evt) {\n          if (!/(38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Retrieve focused index\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\n          if (!items.length) return;\n          var index;\n          angular.forEach(items, function (el, i) {\n            if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;\n          });\n\n          // Navigate with keyboard\n          if (evt.keyCode === 38 && index > 0) index--;\n          else if (evt.keyCode === 40 && index < items.length - 1) index++;\n          else if (angular.isUndefined(index)) index = 0;\n          items.eq(index)[0].focus();\n\n        };\n\n        // Overrides\n\n        var show = $dropdown.show;\n        $dropdown.show = function () {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if (options.keyboard && $dropdown.$element) $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\n            bodyEl.on('click', onBodyClick);\n          }, 0, false);\n          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');\n        };\n\n        var hide = $dropdown.hide;\n        $dropdown.hide = function () {\n          if (!$dropdown.$isShown) return;\n          if (options.keyboard && $dropdown.$element) $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\n          bodyEl.off('click', onBodyClick);\n          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');\n          hide();\n        };\n\n        var destroy = $dropdown.destroy;\n        $dropdown.destroy = function () {\n          bodyEl.off('click', onBodyClick);\n          destroy();\n        };\n\n        // Private functions\n\n        function onBodyClick (evt) {\n          if (evt.target === element[0]) return;\n          return evt.target !== element[0] && $dropdown.hide();\n        }\n\n        return $dropdown;\n\n      }\n\n      return DropdownFactory;\n\n    };\n\n  })\n\n  .directive('bsDropdown', function ($window, $sce, $dropdown) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      compile: function (tElement, tAttrs) {\n\n        // Support for inlined template (next sibling)\n        // It must be fetched before compilation\n        if (!tAttrs.bsDropdown) {\n          var nextSibling = tElement[0].nextSibling;\n          while (nextSibling && nextSibling.nodeType !== 1) {\n            nextSibling = nextSibling.nextSibling;\n          }\n          if (nextSibling && nextSibling.className.split(' ').indexOf('dropdown-menu') >= 0) {\n            tAttrs.template = nextSibling.outerHTML;\n            tAttrs.templateUrl = undefined;\n            nextSibling.parentNode.removeChild(nextSibling);\n          }\n        }\n\n        return function postLink (scope, element, attr) {\n\n          // Directive options\n          var options = {scope: scope};\n          angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function (key) {\n            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];\n          });\n\n          // use string regex match boolean attr falsy values, leave truthy values be\n          var falseValueRegExp = /^(false|0|)$/i;\n          angular.forEach(['html', 'container'], function (key) {\n            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n          });\n\n          // bind functions from the attrs to the show and hide events\n          angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n            var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n            if (angular.isDefined(attr[bsKey])) {\n              options[key] = scope.$eval(attr[bsKey]);\n            }\n          });\n\n          // Support scope as an object\n          if (attr.bsDropdown) {\n            scope.$watch(attr.bsDropdown, function (newValue, oldValue) {\n              scope.content = newValue;\n            }, true);\n          }\n\n          // Initialize dropdown\n          var dropdown = $dropdown(element, options);\n\n          // Visibility binding support\n          if (attr.bsShow) {\n            scope.$watch(attr.bsShow, function (newValue, oldValue) {\n              if (!dropdown || !angular.isDefined(newValue)) return;\n              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\n              if (newValue === true) {\n                dropdown.show();\n              } else {\n                dropdown.hide();\n              }\n            });\n          }\n\n          // Garbage collection\n          scope.$on('$destroy', function () {\n            if (dropdown) dropdown.destroy();\n            options = null;\n            dropdown = null;\n          });\n\n        };\n      }\n    };\n\n  });\n\n// Source: alert/alert.js\n// @BUG: following snippet won't compile correctly\n\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\n\n  .provider('$alert', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'alert',\n      prefixEvent: 'alert',\n      placement: null,\n      templateUrl: 'alert/alert.tpl.html',\n      container: false,\n      element: null,\n      backdrop: false,\n      keyboard: true,\n      show: true,\n      // Specific options\n      duration: false,\n      type: false,\n      dismissible: true\n    };\n\n    this.$get = function ($modal, $timeout) {\n\n      function AlertFactory (config) {\n\n        var $alert = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $alert = $modal(options);\n\n        // Support scope as string options [/*title, content, */ type, dismissible]\n        $alert.$scope.dismissible = !!options.dismissible;\n        if (options.type) {\n          $alert.$scope.type = options.type;\n        }\n\n        // Support auto-close duration\n        var show = $alert.show;\n        if (options.duration) {\n          $alert.show = function () {\n            show();\n            $timeout(function () {\n              $alert.hide();\n            }, options.duration * 1000);\n          };\n        }\n\n        return $alert;\n\n      }\n\n      return AlertFactory;\n\n    };\n\n  })\n\n  .directive('bsAlert', function ($window, $sce, $alert) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissible'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['keyboard', 'html', 'container', 'dismissible'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content', 'type'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsAlert) {\n          scope.$watch(attr.bsAlert, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize alert\n        var alert = $alert(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', alert.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (alert) alert.destroy();\n          options = null;\n          alert = null;\n        });\n\n      }\n    };\n\n  });\n\n// Source: module.js\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.modal',\n  'mgcrea.ngStrap.alert',\n  'mgcrea.ngStrap.select',\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.tooltip',\n  'mgcrea.ngStrap.popover',\n  'mgcrea.ngStrap.dropdown',\n  'mgcrea.ngStrap.tab',\n  'mgcrea.ngStrap.pagination',\n  'mgcrea.ngStrap.sort'\n]);\n\n})(window, document);\n","'use strict';\n\nangular.module('mgcrea.ngStrap.modal', [ 'mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions' ])\n  .provider('$modal', function() {\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      backdropAnimation: 'am-fade',\n      customClass: '',\n      prefixClass: 'modal',\n      prefixEvent: 'modal',\n      placement: 'top',\n      templateUrl: 'modal/modal.tpl.html',\n      template: '',\n      contentTemplate: false,\n      container: false,\n      element: null,\n      backdrop: true,\n      keyboard: true,\n      html: false,\n      show: true,\n      size: null,\n      zIndex: null\n    };\n    this.$get = [ '$window', '$rootScope', '$bsCompiler', '$animate', '$timeout', '$sce', 'dimensions', function($window, $rootScope, $bsCompiler, $animate, $timeout, $sce, dimensions) {\n      var forEach = angular.forEach;\n      var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n      var bodyElement = angular.element($window.document.body);\n      var backdropCount = 0;\n      var dialogBaseZindex = 1050;\n      var backdropBaseZindex = 1040;\n      var validSizes = {\n        lg: 'modal-dialog-lg',\n        sm: 'modal-dialog-sm'\n      };\n      function ModalFactory(config) {\n        var $modal = {};\n        var options = $modal.$options = angular.extend({}, defaults, config);\n        var promise = $modal.$promise = $bsCompiler.compile(options);\n        var scope = $modal.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if (!options.element && !options.container) {\n          options.container = 'body';\n        }\n        if (options.zIndex) {\n          dialogBaseZindex = parseInt(options.zIndex, 10);\n          backdropBaseZindex = dialogBaseZindex - 10;\n        }\n        $modal.$id = options.id || options.element && options.element.attr('id') || '';\n        forEach([ 'title', 'content' ], function(key) {\n          if (options[key]) scope[key] = $sce.trustAsHtml(options[key]);\n        });\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $modal.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $modal.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $modal.toggle();\n          });\n        };\n        $modal.$isShown = scope.$isShown = false;\n        var compileData;\n        var modalElement;\n        var modalScope;\n        var backdropElement = angular.element('<div class=\"' + options.prefixClass + '-backdrop\"/>');\n        promise.then(function(data) {\n          compileData = data;\n          $modal.init();\n        });\n        $modal.init = function() {\n          if (options.show) {\n            scope.$$postDigest(function() {\n              $modal.show();\n            });\n          }\n        };\n        $modal.destroy = function() {\n          destroyModalElement();\n          if (backdropElement) {\n            backdropElement.remove();\n            backdropElement = null;\n          }\n          scope.$destroy();\n        };\n        $modal.show = function() {\n          if ($modal.$isShown) return;\n          var parent;\n          var after;\n          if (angular.isElement(options.container)) {\n            parent = options.container;\n            after = options.container[0].lastChild ? angular.element(options.container[0].lastChild) : null;\n          }\n          else {\n            if (options.container) {\n              parent = findElement(options.container);\n              after = parent[0] && parent[0].lastChild ? angular.element(parent[0].lastChild) : null;\n            } else {\n              parent = null;\n              after = options.element;\n            }\n          }\n          if (options.backdrop) {\n            setScrollBar();\n          }\n          if (modalElement) {\n            destroyModalElement();\n          }\n          modalScope = $modal.$scope.$new();\n          modalElement = $modal.$element = compileData.link(modalScope, function(clonedElement, scope) {});\n          if (options.backdrop) {\n            modalElement.css({\n              'z-index': dialogBaseZindex + backdropCount * 20\n            });\n            backdropElement.css({\n              'z-index': backdropBaseZindex + backdropCount * 20\n            });\n            backdropCount++;\n          }\n          if (scope.$emit(options.prefixEvent + '.show.before', $modal).defaultPrevented) {\n            return;\n          }\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\n            options.onBeforeShow($modal);\n          }\n          modalElement.css({\n            display: 'block'\n          }).addClass(options.placement);\n          if (options.customClass) {\n            modalElement.addClass(options.customClass);\n          }\n          if (options.size && validSizes[options.size]) {\n            angular.element(findElement('.modal-dialog', modalElement[0])).addClass(validSizes[options.size]);\n          }\n          if (options.animation) {\n            if (options.backdrop) {\n              backdropElement.addClass(options.backdropAnimation);\n            }\n            modalElement.addClass(options.animation);\n          }\n          if (options.backdrop) {\n            $animate.enter(backdropElement, bodyElement, null);\n          }\n          if (angular.version.minor <= 2) {\n            $animate.enter(modalElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(modalElement, parent, after).then(enterAnimateCallback);\n          }\n          $modal.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n          var el = modalElement[0];\n          requestAnimationFrame(function() {\n            el.focus();\n          });\n          bodyElement.addClass(options.prefixClass + '-open');\n          if (options.animation) {\n            bodyElement.addClass(options.prefixClass + '-with-' + options.animation);\n          }\n          bindBackdropEvents();\n          bindKeyboardEvents();\n        };\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $modal);\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\n            options.onShow($modal);\n          }\n        }\n        $modal.hide = function() {\n          if (!$modal.$isShown) return;\n          if (scope.$emit(options.prefixEvent + '.hide.before', $modal).defaultPrevented) {\n            return;\n          }\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\n            options.onBeforeHide($modal);\n          }\n          if (angular.version.minor <= 2) {\n            $animate.leave(modalElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(modalElement).then(leaveAnimateCallback);\n          }\n          if (options.backdrop) {\n            backdropCount--;\n            $animate.leave(backdropElement);\n          }\n          $modal.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n          unbindBackdropEvents();\n          unbindKeyboardEvents();\n        };\n        function leaveAnimateCallback() {\n          if (options.backdrop) {\n            resetScrollBar();\n          }\n          scope.$emit(options.prefixEvent + '.hide', $modal);\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\n            options.onHide($modal);\n          }\n          if (findElement('.modal').length <= 0) {\n            bodyElement.removeClass(options.prefixClass + '-open');\n          }\n          if (options.animation) {\n            bodyElement.removeClass(options.prefixClass + '-with-' + options.animation);\n          }\n        }\n        $modal.toggle = function() {\n          if ($modal.$isShown) {\n            $modal.hide();\n          } else {\n            $modal.show();\n          }\n        };\n        $modal.focus = function() {\n          modalElement[0].focus();\n        };\n        $modal.$onKeyUp = function(evt) {\n          if (evt.which === 27 && $modal.$isShown) {\n            $modal.hide();\n            evt.stopPropagation();\n          }\n        };\n        function bindBackdropEvents() {\n          if (options.backdrop) {\n            modalElement.on('click', hideOnBackdropClick);\n            backdropElement.on('click', hideOnBackdropClick);\n            backdropElement.on('wheel', preventEventDefault);\n          }\n        }\n        function unbindBackdropEvents() {\n          if (options.backdrop) {\n            modalElement.off('click', hideOnBackdropClick);\n            backdropElement.off('click', hideOnBackdropClick);\n            backdropElement.off('wheel', preventEventDefault);\n          }\n        }\n        function bindKeyboardEvents() {\n          if (options.keyboard) {\n            modalElement.on('keyup', $modal.$onKeyUp);\n          }\n        }\n        function unbindKeyboardEvents() {\n          if (options.keyboard) {\n            modalElement.off('keyup', $modal.$onKeyUp);\n          }\n        }\n        function hideOnBackdropClick(evt) {\n          if (evt.target !== evt.currentTarget) return;\n          if (options.backdrop === 'static') {\n            $modal.focus();\n          } else {\n            $modal.hide();\n          }\n        }\n        function preventEventDefault(evt) {\n          evt.preventDefault();\n        }\n        function destroyModalElement() {\n          if ($modal.$isShown && modalElement !== null) {\n            unbindBackdropEvents();\n            unbindKeyboardEvents();\n          }\n          if (modalScope) {\n            modalScope.$destroy();\n            modalScope = null;\n          }\n          if (modalElement) {\n            modalElement.remove();\n            modalElement = $modal.$element = null;\n          }\n        }\n        function setScrollBar() {\n          var scrollDiv = document.createElement('div');\n          scrollDiv.className = 'modal-scrollbar-measure';\n          bodyElement.append(scrollDiv);\n          var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n          bodyElement[0].removeChild(scrollDiv);\n\n          var fullWindowWidth = window.innerWidth;\n          if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8\n            var documentElementRect = document.documentElement.getBoundingClientRect();\n            fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);\n          }\n          var bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;\n\n          if (bodyIsOverflowing) bodyElement.css('padding-right', scrollbarWidth + 'px');\n        }\n        function resetScrollBar() {\n          bodyElement.css('padding-right', 0);\n        }\n        return $modal;\n      }\n      function safeDigest(scope) {\n        scope.$$phase || scope.$root && scope.$root.$$phase || scope.$digest();\n      }\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n      return ModalFactory;\n    } ];\n  }).directive('bsModal', [ '$window', '$sce', '$parse', '$modal', function($window, $sce, $parse, $modal) {\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n        var options = {\n          scope: scope,\n          element: element,\n          show: false\n        };\n        angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'backdrop', 'keyboard', 'html', 'container', 'animation', 'backdropAnimation', 'id', 'prefixEvent', 'prefixClass', 'customClass', 'modalClass', 'size', 'zIndex' ], function(key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n        if (options.modalClass) {\n          options.customClass = options.modalClass;\n        }\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach([ 'backdrop', 'keyboard', 'html', 'container' ], function(key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n        angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide' ], function(key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n        angular.forEach([ 'title', 'content' ], function(key) {\n          if (attr[key]) {\n            attr.$observe(key, function(newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n        if (attr.bsModal) {\n          scope.$watch(attr.bsModal, function(newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n        var modal = $modal(options);\n        element.on(attr.trigger || 'click', modal.toggle);\n        scope.$on('$destroy', function() {\n          if (modal) modal.destroy();\n          options = null;\n          modal = null;\n        });\n      }\n    };\n  } ]);\n","'use strict';\n\n// NOTICE: This file was forked from the angular-material project (github.com/angular/material)\n// MIT Licensed - Copyright (c) 2014-2015 Google, Inc. http://angularjs.org\n\nangular.module('mgcrea.ngStrap.core', [])\n  .service('$bsCompiler', bsCompilerService);\n\nfunction bsCompilerService ($q, $http, $injector, $compile, $controller, $templateCache) {\n\n  /*\n   * @ngdoc service\n   * @name $bsCompiler\n   * @module material.core\n   * @description\n   * The $bsCompiler service is an abstraction of angular's compiler, that allows the developer\n   * to easily compile an element with a templateUrl, controller, and locals.\n   *\n   * @usage\n   * <hljs lang=\"js\">\n   * $bsCompiler.compile({\n   *   templateUrl: 'modal.html',\n   *   controller: 'ModalCtrl',\n   *   locals: {\n   *     modal: myModalInstance;\n   *   }\n   * }).then(function(compileData) {\n   *   compileData.element; // modal.html's template in an element\n   *   compileData.link(myScope); //attach controller & scope to element\n   * });\n   * </hljs>\n   */\n\n   /*\n    * @ngdoc method\n    * @name $bsCompiler#compile\n    * @description A helper to compile an HTML template/templateUrl with a given controller,\n    * locals, and scope.\n    * @param {object} options An options object, with the following properties:\n    *\n    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with\n    *      newly created scope or the name of a registered controller if passed as a string.\n    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be\n    *      published to scope under the `controllerAs` name.\n    *    - `template` - `{string=}` An html template as a string.\n    *    - `templateUrl` - `{string=}` A path to an html template.\n    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after\n    *      it is loaded. It will be given the template string as a parameter, and should\n    *      return a a new string representing the transformed template.\n    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n    *      be injected into the controller. If any of these dependencies are promises, the compiler\n    *      will wait for them all to be resolved, or if one is rejected before the controller is\n    *      instantiated `compile()` will fail..\n    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.\n    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.\n    *        Otherwise if function, then it is injected and the return value is treated as the\n    *        dependency. If the result is a promise, it is resolved before its value is\n    *        injected into the controller.\n    *\n    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.\n    * `compileData` has the following properties:\n    *\n    *   - `element` - `{element}`: an uncompiled element matching the provided template.\n    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile\n    *     the element and instantiate the provided controller (if given).\n    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is\n    *     called. If `bindToController` is true, they will be coppied to the ctrl instead\n    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.\n    */\n  this.compile = function (options) {\n\n    if (options.template && /\\.html$/.test(options.template)) {\n      console.warn('Deprecated use of `template` option to pass a file. Please use the `templateUrl` option instead.');\n      options.templateUrl = options.template;\n      options.template = '';\n    }\n\n    var templateUrl = options.templateUrl;\n    var template = options.template || '';\n    var controller = options.controller;\n    var controllerAs = options.controllerAs;\n    var resolve = angular.copy(options.resolve || {});\n    var locals = angular.copy(options.locals || {});\n    var transformTemplate = options.transformTemplate || angular.identity;\n    var bindToController = options.bindToController;\n\n    // Take resolve values and invoke them.\n    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),\n    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})\n    angular.forEach(resolve, function (value, key) {\n      if (angular.isString(value)) {\n        resolve[key] = $injector.get(value);\n      } else {\n        resolve[key] = $injector.invoke(value);\n      }\n    });\n    // Add the locals, which are just straight values to inject\n    // eg locals: { three: 3 }, will inject three into the controller\n    angular.extend(resolve, locals);\n\n    if (template) {\n      resolve.$template = $q.when(template);\n    } else if (templateUrl) {\n      resolve.$template = fetchTemplate(templateUrl);\n    } else {\n      throw new Error('Missing `template` / `templateUrl` option.');\n    }\n\n    if (options.titleTemplate) {\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.titleTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          findElement('[ng-bind=\"title\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    if (options.contentTemplate) {\n      // TODO(mgcrea): deprecate?\n      resolve.$template = $q.all([resolve.$template, fetchTemplate(options.contentTemplate)])\n        .then(function (templates) {\n          var templateEl = angular.element(templates[0]);\n          var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0])\n            .removeAttr('ng-bind')\n            .html(templates[1]);\n          // Drop the default footer as you probably don't want it if you use a custom contentTemplate\n          if (!options.templateUrl) contentEl.next().remove();\n          return templateEl[0].outerHTML;\n        });\n    }\n\n    // Wait for all the resolves to finish if they are promises\n    return $q.all(resolve).then(function (locals) {\n\n      var template = transformTemplate(locals.$template);\n      if (options.html) {\n        template = template.replace(/ng-bind=\"/ig, 'ng-bind-html=\"');\n      }\n      // var element = options.element || angular.element('<div>').html(template.trim()).contents();\n      var element = angular.element('<div>').html(template.trim()).contents();\n      var linkFn = $compile(element);\n\n      // Return a linking function that can be used later when the element is ready\n      return {\n        locals: locals,\n        element: element,\n        link: function link (scope) {\n          locals.$scope = scope;\n\n          // Instantiate controller if it exists, because we have scope\n          if (controller) {\n            var invokeCtrl = $controller(controller, locals, true);\n            if (bindToController) {\n              angular.extend(invokeCtrl.instance, locals);\n            }\n            // Support angular@~1.2 invokeCtrl\n            var ctrl = angular.isObject(invokeCtrl) ? invokeCtrl : invokeCtrl();\n            // See angular-route source for this logic\n            element.data('$ngControllerController', ctrl);\n            element.children().data('$ngControllerController', ctrl);\n\n            if (controllerAs) {\n              scope[controllerAs] = ctrl;\n            }\n          }\n\n          return linkFn.apply(null, arguments);\n        }\n      };\n    });\n\n  };\n\n  function findElement (query, element) {\n    return angular.element((element || document).querySelectorAll(query));\n  }\n\n  var fetchPromises = {};\n  function fetchTemplate (template) {\n    if (fetchPromises[template]) return fetchPromises[template];\n    return (fetchPromises[template] = $http.get(template, {cache: $templateCache})\n      .then(function (res) {\n        return res.data;\n      }));\n  }\n\n}\n","'use strict';\n\nangular.module('mgcrea.ngStrap.datepicker', [ 'mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip' ]).provider('$datepicker', function() {\n  var defaults = this.defaults = {\n    animation: 'am-fade',\n    prefixClass: 'datepicker',\n    placement: 'bottom-left',\n    templateUrl: 'datepicker/datepicker.tpl.html',\n    trigger: 'focus',\n    container: false,\n    keyboard: true,\n    html: false,\n    delay: 0,\n    useNative: false,\n    dateType: 'date',\n    dateFormat: 'shortDate',\n    timezone: null,\n    modelDateFormat: null,\n    dayFormat: 'dd',\n    monthFormat: 'MMM',\n    yearFormat: 'yyyy',\n    monthTitleFormat: 'MMMM yyyy',\n    yearTitleFormat: 'yyyy',\n    strictFormat: false,\n    autoclose: false,\n    minDate: -Infinity,\n    maxDate: +Infinity,\n    startView: 0,\n    minView: 0,\n    startWeek: 0,\n    daysOfWeekDisabled: '',\n    hasToday: false,\n    hasClear: false,\n    iconLeft: 'nox-sort-left',\n    iconRight: 'nox-sort-right'\n  };\n  this.$get = [ '$window', '$document', '$rootScope', '$sce', '$dateFormatter', 'datepickerViews', '$tooltip', '$timeout', function($window, $document, $rootScope, $sce, $dateFormatter, datepickerViews, $tooltip, $timeout) {\n    var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);\n    var isTouch = 'createTouch' in $window.document && isNative;\n    if (!defaults.lang) defaults.lang = $dateFormatter.getDefaultLocale();\n    function DatepickerFactory(element, controller, config) {\n      var $datepicker = $tooltip(element, angular.extend({}, defaults, config));\n      var parentScope = config.scope;\n      var options = $datepicker.$options;\n      var scope = $datepicker.$scope;\n      if (options.startView) options.startView -= options.minView;\n      var pickerViews = datepickerViews($datepicker);\n      $datepicker.$views = pickerViews.views;\n      var viewDate = pickerViews.viewDate;\n      scope.$mode = options.startView;\n      scope.$iconLeft = options.iconLeft;\n      scope.$iconRight = options.iconRight;\n      scope.$hasToday = options.hasToday;\n      scope.$hasClear = options.hasClear;\n      var $picker = $datepicker.$views[scope.$mode];\n      scope.$select = function(date) {\n        $datepicker.select(date);\n      };\n      scope.$selectPane = function(value) {\n        $datepicker.$selectPane(value);\n      };\n      scope.$toggleMode = function() {\n        $datepicker.setMode((scope.$mode + 1) % $datepicker.$views.length);\n      };\n      scope.$setToday = function() {\n        if (options.autoclose) {\n          $datepicker.setMode(0);\n          $datepicker.select(new Date());\n        } else {\n          $datepicker.select(new Date(), true);\n        }\n      };\n      scope.$clear = function() {\n        if (options.autoclose) {\n          $datepicker.setMode(0);\n          $datepicker.select(null);\n        } else {\n          $datepicker.select(null, true);\n        }\n      };\n      $datepicker.update = function(date) {\n        if (angular.isDate(date) && !isNaN(date.getTime())) {\n          $datepicker.$date = date;\n          $picker.update.call($picker, date);\n        }\n        $datepicker.$build(true);\n      };\n      $datepicker.updateDisabledDates = function(dateRanges) {\n        options.disabledDateRanges = dateRanges;\n        for (var i = 0, l = scope.rows.length; i < l; i++) {\n          angular.forEach(scope.rows[i], $datepicker.$setDisabledEl);\n        }\n      };\n      $datepicker.select = function(date, keep) {\n        if (angular.isDate(date)) {\n          if (!angular.isDate(controller.$dateValue) || isNaN(controller.$dateValue.getTime())) {\n            controller.$dateValue = new Date(date);\n          }\n        } else {\n          controller.$dateValue = null;\n        }\n        if (!scope.$mode || keep) {\n          controller.$setViewValue(angular.copy(date));\n          controller.$render();\n          if (options.autoclose && !keep) {\n            $timeout(function() {\n              $datepicker.hide(true);\n            });\n          }\n        } else {\n          angular.extend(viewDate, {\n            year: date.getFullYear(),\n            month: date.getMonth(),\n            date: date.getDate()\n          });\n          $datepicker.setMode(scope.$mode - 1);\n          $datepicker.$build();\n        }\n      };\n      $datepicker.setMode = function(mode) {\n        scope.$mode = mode;\n        $picker = $datepicker.$views[scope.$mode];\n        $datepicker.$build();\n      };\n      $datepicker.$build = function(pristine) {\n        if (pristine === true && $picker.built) return;\n        if (pristine === false && !$picker.built) return;\n        $picker.build.call($picker);\n      };\n      $datepicker.$updateSelected = function() {\n        for (var i = 0, l = scope.rows.length; i < l; i++) {\n          angular.forEach(scope.rows[i], updateSelected);\n        }\n      };\n      $datepicker.$isSelected = function(date) {\n        return $picker.isSelected(date);\n      };\n      $datepicker.$setDisabledEl = function(el) {\n        el.disabled = $picker.isDisabled(el.date);\n      };\n      $datepicker.$selectPane = function(value) {\n        var steps = $picker.steps;\n        var targetDate = new Date(Date.UTC(viewDate.year + (steps.year || 0) * value, viewDate.month + (steps.month || 0) * value, 1));\n        angular.extend(viewDate, {\n          year: targetDate.getUTCFullYear(),\n          month: targetDate.getUTCMonth(),\n          date: targetDate.getUTCDate()\n        });\n        $datepicker.$build();\n      };\n      $datepicker.$onMouseDown = function(evt) {\n        evt.preventDefault();\n        evt.stopPropagation();\n        if (isTouch) {\n          var targetEl = angular.element(evt.target);\n          if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n            targetEl = targetEl.parent();\n          }\n          targetEl.triggerHandler('click');\n        }\n      };\n      $datepicker.$onKeyDown = function(evt) {\n        if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n        evt.preventDefault();\n        evt.stopPropagation();\n        if (evt.keyCode === 13) {\n          if (!scope.$mode) {\n            $datepicker.hide(true);\n          } else {\n            scope.$apply(function() {\n              $datepicker.setMode(scope.$mode - 1);\n            });\n          }\n          return;\n        }\n        $picker.onKeyDown(evt);\n        parentScope.$digest();\n      };\n      function updateSelected(el) {\n        el.selected = $datepicker.$isSelected(el.date);\n      }\n      function focusElement() {\n        element[0].focus();\n      }\n      var _init = $datepicker.init;\n      $datepicker.init = function() {\n        if (isNative && options.useNative) {\n          element.prop('type', 'date');\n          element.css('-webkit-appearance', 'textfield');\n          return;\n        } else if (isTouch) {\n          element.prop('type', 'text');\n          element.attr('readonly', 'true');\n          element.on('click', focusElement);\n        }\n        _init();\n      };\n      var _destroy = $datepicker.destroy;\n      $datepicker.destroy = function() {\n        if (isNative && options.useNative) {\n          element.off('click', focusElement);\n        }\n        _destroy();\n      };\n      var _show = $datepicker.show;\n      $datepicker.show = function() {\n        if (!isTouch && element.attr('readonly') || element.attr('disabled')) return;\n        _show();\n        $timeout(function() {\n          if (!$datepicker.$isShown) return;\n          $datepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n          if (options.keyboard) {\n            element.on('keydown', $datepicker.$onKeyDown);\n          }\n        }, 0, false);\n      };\n      var _hide = $datepicker.hide;\n      $datepicker.hide = function(blur) {\n        if (!$datepicker.$isShown) return;\n        $datepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $datepicker.$onMouseDown);\n        if (options.keyboard) {\n          element.off('keydown', $datepicker.$onKeyDown);\n        }\n        _hide(blur);\n      };\n      return $datepicker;\n    }\n    DatepickerFactory.defaults = defaults;\n    return DatepickerFactory;\n  } ];\n}).directive('bsDatepicker', [ '$window', '$parse', '$q', '$dateFormatter', '$dateParser', '$datepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $datepicker) {\n  var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);\n  return {\n    restrict: 'EAC',\n    require: 'ngModel',\n    link: function postLink(scope, element, attr, controller) {\n      var options = {\n        scope: scope\n      };\n      angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'autoclose', 'dateType', 'dateFormat', 'timezone', 'modelDateFormat', 'dayFormat', 'strictFormat', 'startWeek', 'startDate', 'useNative', 'lang', 'startView', 'minView', 'iconLeft', 'iconRight', 'daysOfWeekDisabled', 'id', 'prefixClass', 'prefixEvent', 'hasToday', 'hasClear' ], function(key) {\n        if (angular.isDefined(attr[key])) options[key] = attr[key];\n      });\n      var falseValueRegExp = /^(false|0|)$/i;\n      angular.forEach([ 'html', 'container', 'autoclose', 'useNative', 'hasToday', 'hasClear' ], function(key) {\n        if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n          options[key] = false;\n        }\n      });\n      angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide' ], function(key) {\n        var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n        if (angular.isDefined(attr[bsKey])) {\n          options[key] = scope.$eval(attr[bsKey]);\n        }\n      });\n      var datepicker = $datepicker(element, controller, options);\n      options = datepicker.$options;\n      if (isNative && options.useNative) options.dateFormat = 'yyyy-MM-dd';\n      var lang = options.lang;\n      var formatDate = function(date, format) {\n        return $dateFormatter.formatDate(date, format, lang);\n      };\n      var dateParser = $dateParser({\n        format: options.dateFormat,\n        lang: lang,\n        strict: options.strictFormat\n      });\n      if (attr.bsShow) {\n        scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if (!datepicker || !angular.isDefined(newValue)) return;\n          if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(datepicker),?/i);\n          if (newValue === true) {\n            datepicker.show();\n          } else {\n            datepicker.hide();\n          }\n        });\n      }\n      angular.forEach([ 'minDate', 'maxDate' ], function(key) {\n        if (angular.isDefined(attr[key])) {\n          attr.$observe(key, function(newValue) {\n            datepicker.$options[key] = dateParser.getDateForAttribute(key, newValue);\n            if (!isNaN(datepicker.$options[key])) datepicker.$build(false);\n            validateAgainstMinMaxDate(controller.$dateValue);\n          });\n        }\n      });\n      if (angular.isDefined(attr.dateFormat)) {\n        attr.$observe('dateFormat', function(newValue) {\n          datepicker.$options.dateFormat = newValue;\n        });\n      }\n      scope.$watch(attr.ngModel, function(newValue, oldValue) {\n        datepicker.update(controller.$dateValue);\n      }, true);\n      function normalizeDateRanges(ranges) {\n        if (!ranges || !ranges.length) return null;\n        return ranges;\n      }\n      if (angular.isDefined(attr.disabledDates)) {\n        scope.$watch(attr.disabledDates, function(disabledRanges, previousValue) {\n          disabledRanges = normalizeDateRanges(disabledRanges);\n          previousValue = normalizeDateRanges(previousValue);\n          if (disabledRanges) {\n            datepicker.updateDisabledDates(disabledRanges);\n          }\n        });\n      }\n      function validateAgainstMinMaxDate(parsedDate) {\n        if (!angular.isDate(parsedDate)) return;\n        var isMinValid = isNaN(datepicker.$options.minDate) || parsedDate.getTime() >= datepicker.$options.minDate;\n        var isMaxValid = isNaN(datepicker.$options.maxDate) || parsedDate.getTime() <= datepicker.$options.maxDate;\n        var isValid = isMinValid && isMaxValid;\n        controller.$setValidity('date', isValid);\n        controller.$setValidity('min', isMinValid);\n        controller.$setValidity('max', isMaxValid);\n        if (isValid) controller.$dateValue = parsedDate;\n      }\n      controller.$parsers.unshift(function(viewValue) {\n        var date;\n        if (!viewValue) {\n          controller.$setValidity('date', true);\n          return null;\n        }\n        var parsedDate = dateParser.parse(viewValue, controller.$dateValue);\n        if (!parsedDate || isNaN(parsedDate.getTime())) {\n          controller.$setValidity('date', false);\n          return;\n        }\n        validateAgainstMinMaxDate(parsedDate);\n        if (options.dateType === 'string') {\n          date = dateParser.timezoneOffsetAdjust(parsedDate, options.timezone, true);\n          return formatDate(date, options.modelDateFormat || options.dateFormat);\n        }\n        date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n        if (options.dateType === 'number') {\n          return date.getTime();\n        } else if (options.dateType === 'unix') {\n          return date.getTime() / 1e3;\n        } else if (options.dateType === 'iso') {\n          return date.toISOString();\n        }\n        return new Date(date);\n      });\n      controller.$formatters.push(function(modelValue) {\n        var date;\n        if (angular.isUndefined(modelValue) || modelValue === null) {\n          date = NaN;\n        } else if (angular.isDate(modelValue)) {\n          date = modelValue;\n        } else if (options.dateType === 'string') {\n          date = dateParser.parse(modelValue, null, options.modelDateFormat);\n        } else if (options.dateType === 'unix') {\n          date = new Date(modelValue * 1e3);\n        } else {\n          date = new Date(modelValue);\n        }\n        controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n        return getDateFormattedString();\n      });\n      controller.$render = function() {\n        element.val(getDateFormattedString());\n      };\n      function getDateFormattedString() {\n        return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.dateFormat);\n      }\n      scope.$on('$destroy', function() {\n        if (datepicker) datepicker.destroy();\n        options = null;\n        datepicker = null;\n      });\n    }\n  };\n} ]).provider('datepickerViews', function() {\n  function split(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  }\n  function mod(n, m) {\n    return (n % m + m) % m;\n  }\n  this.$get = [ '$dateFormatter', '$dateParser', '$sce', function($dateFormatter, $dateParser, $sce) {\n    return function(picker) {\n      var scope = picker.$scope;\n      var options = picker.$options;\n      var lang = options.lang;\n      var formatDate = function(date, format) {\n        return $dateFormatter.formatDate(date, format, lang);\n      };\n      var dateParser = $dateParser({\n        format: options.dateFormat,\n        lang: lang,\n        strict: options.strictFormat\n      });\n      var weekDaysMin = $dateFormatter.weekdaysShort(lang);\n      var weekDaysLabels = weekDaysMin.slice(options.startWeek).concat(weekDaysMin.slice(0, options.startWeek));\n      var weekDaysLabelsHtml = $sce.trustAsHtml('<th class=\"dow text-center\">' + weekDaysLabels.join('</th><th class=\"dow text-center\">') + '</th>');\n      var startDate = picker.$date || (options.startDate ? dateParser.getDateForAttribute('startDate', options.startDate) : new Date());\n      var viewDate = {\n        year: startDate.getFullYear(),\n        month: startDate.getMonth(),\n        date: startDate.getDate()\n      };\n      var views = [ {\n        format: options.dayFormat,\n        split: 7,\n        steps: {\n          month: 1\n        },\n        update: function(date, force) {\n          if (!this.built || force || date.getFullYear() !== viewDate.year || date.getMonth() !== viewDate.month) {\n            angular.extend(viewDate, {\n              year: picker.$date.getFullYear(),\n              month: picker.$date.getMonth(),\n              date: picker.$date.getDate()\n            });\n            picker.$build();\n          } else if (date.getDate() !== viewDate.date || date.getDate() === 1) {\n            viewDate.date = picker.$date.getDate();\n            picker.$updateSelected();\n          }\n        },\n        build: function() {\n          var firstDayOfMonth = new Date(viewDate.year, viewDate.month, 1);\n          var firstDayOfMonthOffset = firstDayOfMonth.getTimezoneOffset();\n          var firstDate = new Date(+firstDayOfMonth - mod(firstDayOfMonth.getDay() - options.startWeek, 7) * 864e5);\n          var firstDateOffset = firstDate.getTimezoneOffset();\n          var today = dateParser.timezoneOffsetAdjust(new Date(), options.timezone).toDateString();\n          if (firstDateOffset !== firstDayOfMonthOffset) firstDate = new Date(+firstDate + (firstDateOffset - firstDayOfMonthOffset) * 6e4);\n          var days = [];\n          var day;\n          for (var i = 0; i < 42; i++) {\n            day = dateParser.daylightSavingAdjust(new Date(firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate() + i));\n            days.push({\n              date: day,\n              isToday: day.toDateString() === today,\n              label: formatDate(day, this.format),\n              selected: picker.$date && this.isSelected(day),\n              muted: day.getMonth() !== viewDate.month,\n              disabled: this.isDisabled(day)\n            });\n          }\n          scope.title = formatDate(firstDayOfMonth, options.monthTitleFormat);\n          scope.showLabels = true;\n          scope.labels = weekDaysLabelsHtml;\n          scope.rows = split(days, this.split);\n          scope.isTodayDisabled = this.isDisabled(new Date());\n          this.built = true;\n        },\n        isSelected: function(date) {\n          return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth() && date.getDate() === picker.$date.getDate();\n        },\n        isDisabled: function(date) {\n          var time = date.getTime();\n          if (time < Date.parse(options.minDate) || time > Date.parse(options.maxDate)) return true;\n          if (options.daysOfWeekDisabled.indexOf(date.getDay()) !== -1) return true;\n          if (options.disabledDateRanges) {\n            for (var i = 0; i < options.disabledDateRanges.length; i++) {\n              if (time >= options.disabledDateRanges[i].start && time <= options.disabledDateRanges[i].end) {\n                return true;\n              }\n            }\n          }\n          return false;\n        },\n        onKeyDown: function(evt) {\n          if (!picker.$date) {\n            return;\n          }\n          var actualTime = picker.$date.getTime();\n          var newDate;\n          if (evt.keyCode === 37) newDate = new Date(actualTime - 1 * 864e5); else if (evt.keyCode === 38) newDate = new Date(actualTime - 7 * 864e5); else if (evt.keyCode === 39) newDate = new Date(actualTime + 1 * 864e5); else if (evt.keyCode === 40) newDate = new Date(actualTime + 7 * 864e5);\n          if (!this.isDisabled(newDate)) picker.select(newDate, true);\n        }\n      }, {\n        name: 'month',\n        format: options.monthFormat,\n        split: 4,\n        steps: {\n          year: 1\n        },\n        update: function(date, force) {\n          if (!this.built || date.getFullYear() !== viewDate.year) {\n            angular.extend(viewDate, {\n              year: picker.$date.getFullYear(),\n              month: picker.$date.getMonth(),\n              date: picker.$date.getDate()\n            });\n            picker.$build();\n          } else if (date.getMonth() !== viewDate.month) {\n            angular.extend(viewDate, {\n              month: picker.$date.getMonth(),\n              date: picker.$date.getDate()\n            });\n            picker.$updateSelected();\n          }\n        },\n        build: function() {\n          var months = [];\n          var month;\n          for (var i = 0; i < 12; i++) {\n            month = new Date(viewDate.year, i, 1);\n            months.push({\n              date: month,\n              label: formatDate(month, this.format),\n              selected: picker.$isSelected(month),\n              disabled: this.isDisabled(month)\n            });\n          }\n          scope.title = formatDate(month, options.yearTitleFormat);\n          scope.showLabels = false;\n          scope.rows = split(months, this.split);\n          this.built = true;\n        },\n        isSelected: function(date) {\n          return picker.$date && date.getFullYear() === picker.$date.getFullYear() && date.getMonth() === picker.$date.getMonth();\n        },\n        isDisabled: function(date) {\n          var lastDate = +new Date(date.getFullYear(), date.getMonth() + 1, 0);\n          return lastDate < options.minDate || date.getTime() > options.maxDate;\n        },\n        onKeyDown: function(evt) {\n          if (!picker.$date) {\n            return;\n          }\n          var actualMonth = picker.$date.getMonth();\n          var newDate = new Date(picker.$date);\n          if (evt.keyCode === 37) newDate.setMonth(actualMonth - 1); else if (evt.keyCode === 38) newDate.setMonth(actualMonth - 4); else if (evt.keyCode === 39) newDate.setMonth(actualMonth + 1); else if (evt.keyCode === 40) newDate.setMonth(actualMonth + 4);\n          if (!this.isDisabled(newDate)) picker.select(newDate, true);\n        }\n      }, {\n        name: 'year',\n        format: options.yearFormat,\n        split: 4,\n        steps: {\n          year: 12\n        },\n        update: function(date, force) {\n          if (!this.built || force || parseInt(date.getFullYear() / 20, 10) !== parseInt(viewDate.year / 20, 10)) {\n            angular.extend(viewDate, {\n              year: picker.$date.getFullYear(),\n              month: picker.$date.getMonth(),\n              date: picker.$date.getDate()\n            });\n            picker.$build();\n          } else if (date.getFullYear() !== viewDate.year) {\n            angular.extend(viewDate, {\n              year: picker.$date.getFullYear(),\n              month: picker.$date.getMonth(),\n              date: picker.$date.getDate()\n            });\n            picker.$updateSelected();\n          }\n        },\n        build: function() {\n          var firstYear = viewDate.year - viewDate.year % (this.split * 3);\n          var years = [];\n          var year;\n          for (var i = 0; i < 12; i++) {\n            year = new Date(firstYear + i, 0, 1);\n            years.push({\n              date: year,\n              label: formatDate(year, this.format),\n              selected: picker.$isSelected(year),\n              disabled: this.isDisabled(year)\n            });\n          }\n          scope.title = years[0].label + '-' + years[years.length - 1].label;\n          scope.showLabels = false;\n          scope.rows = split(years, this.split);\n          this.built = true;\n        },\n        isSelected: function(date) {\n          return picker.$date && date.getFullYear() === picker.$date.getFullYear();\n        },\n        isDisabled: function(date) {\n          var lastDate = +new Date(date.getFullYear() + 1, 0, 0);\n          return lastDate < options.minDate || date.getTime() > options.maxDate;\n        },\n        onKeyDown: function(evt) {\n          if (!picker.$date) {\n            return;\n          }\n          var actualYear = picker.$date.getFullYear();\n          var newDate = new Date(picker.$date);\n          if (evt.keyCode === 37) newDate.setYear(actualYear - 1); else if (evt.keyCode === 38) newDate.setYear(actualYear - 4); else if (evt.keyCode === 39) newDate.setYear(actualYear + 1); else if (evt.keyCode === 40) newDate.setYear(actualYear + 4);\n          if (!this.isDisabled(newDate)) picker.select(newDate, true);\n        }\n      } ];\n      return {\n        views: options.minView ? Array.prototype.slice.call(views, options.minView) : views,\n        viewDate: viewDate\n      };\n    };\n  } ];\n});\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.core', 'mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      templateUrl: 'tooltip/tooltip.tpl.html',\n      template: '',\n      titleTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      mouseDownPreventDefault: true,\n      mouseDownStopPropagation: true,\n      viewport: {\n        selector: 'body',\n        padding: 0\n      }\n    };\n\n    this.$get = function ($window, $rootScope, $bsCompiler, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory (element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        var promise = $tooltip.$promise = $bsCompiler.compile(options);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        var nodeName = element[0].nodeName.toLowerCase();\n        if (options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // Store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if (options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function (isEnabled) {\n          scope.$$postDigest(function () {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function () {\n          scope.$$postDigest(function () {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function () {\n          scope.$$postDigest(function () {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function () {\n          scope.$$postDigest(function () {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout;\n        var hoverState;\n\n        // Fetch, compile then initialize tooltip\n        var compileData;\n        var tipElement;\n        var tipContainer;\n        var tipScope;\n        promise.then(function (data) {\n          compileData = data;\n          $tooltip.init();\n        });\n\n        $tooltip.init = function () {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if (options.container === 'self') {\n            tipContainer = element;\n          } else if (angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if (options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if (options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if (options.show) {\n            scope.$$postDigest(function () {\n              if (options.trigger === 'focus') {\n                element[0].focus();\n              } else {\n                $tooltip.show();\n              }\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function () {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function () {\n            if (hoverState === 'in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function () {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          if (angular.isDefined(options.onBeforeShow) && angular.isFunction(options.onBeforeShow)) {\n            options.onBeforeShow($tooltip);\n          }\n          var parent;\n          var after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if (tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = compileData.link(tipScope, function (clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if (options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if (options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if (options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          if (after) {\n            after.after(tipElement);\n          } else {\n            parent.prepend(tipElement);\n          }\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if (tipElement) tipElement.css({visibility: 'visible'});\n\n            // Bind events\n            if (options.keyboard) {\n              if (options.trigger !== 'focus') {\n                $tooltip.focus();\n              }\n              bindKeyboardEvents();\n            }\n          });\n\n          if (options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n          if (angular.isDefined(options.onShow) && angular.isFunction(options.onShow)) {\n            options.onShow($tooltip);\n          }\n        }\n\n        $tooltip.leave = function () {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function (blur) {\n\n          if (!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n          if (angular.isDefined(options.onBeforeHide) && angular.isFunction(options.onBeforeHide)) {\n            options.onBeforeHide($tooltip);\n          }\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if (angular.version.minor <= 2) {\n            $animate.leave(tipElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(tipElement).then(leaveAnimateCallback);\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if (options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if (options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback () {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n          if (angular.isDefined(options.onHide) && angular.isFunction(options.onHide)) {\n            options.onHide($tooltip);\n          }\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if (_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function (evt) {\n          if (evt) { evt.preventDefault(); }\n          if ($tooltip.$isShown) {\n            $tooltip.leave();\n          } else {\n            $tooltip.enter();\n          }\n        };\n\n        $tooltip.focus = function () {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function (isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function (viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function () {\n          if (!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement;\n          var autoToken = /\\s?auto?\\s?/i;\n          var autoPlace = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition();\n          var tipWidth = tipElement.prop('offsetWidth');\n          var tipHeight = tipElement.prop('offsetHeight');\n\n          // Refresh viewport position\n          $tooltip.$viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var viewportPosition = getPosition($tooltip.$viewport);\n\n            if (/bottom/.test(originalPlacement) && elementPosition.bottom + tipHeight > viewportPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (/top/.test(originalPlacement) && elementPosition.top - tipHeight < viewportPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            if (/left/.test(originalPlacement) && elementPosition.left - tipWidth < viewportPosition.left) {\n              placement = placement.replace('left', 'right');\n            } else if (/right/.test(originalPlacement) && elementPosition.right + tipWidth > viewportPosition.width) {\n              placement = placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function (evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function (evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function (evt) {\n          if (options.mouseDownPreventDefault) { evt.preventDefault(); }\n          if (options.mouseDownStopPropagation) { evt.stopPropagation(); }\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          if ($tooltip.$isShown) {\n            element[0].blur();\n          } else {\n            element[0].focus();\n          }\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function (trigger) {\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.on(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          });\n        }\n\n        function unbindTriggerEvents () {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if (trigger === 'click' || trigger === 'contextmenu') {\n              element.off(trigger, $tooltip.toggle);\n            } else if (trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              if (nodeName === 'button' && trigger !== 'hover') {\n                element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n              }\n            }\n          }\n        }\n\n        function bindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents () {\n          if (options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents () {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents () {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation (event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition ($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0];\n          var isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          /* eslint-disable guard-for-in */\n          for (var p in elRect) { // eslint-disable-line\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n          /* eslint-enable guard-for-in */\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top});\n          }\n          var elOffset = isBody ? {top: 0, left: 0} : dimensions.offset(el);\n          var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0};\n          var outerDims = isBody ? {width: document.documentElement.clientWidth, height: $window.innerHeight} : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset (placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n            case 'right':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left + position.width\n              };\n              break;\n            case 'bottom':\n              offset = {\n                top: position.top + position.height,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n            case 'left':\n              offset = {\n                top: position.top + position.height / 2 - actualHeight / 2,\n                left: position.left - actualWidth\n              };\n              break;\n            default:\n              offset = {\n                top: position.top - actualHeight,\n                left: position.left + position.width / 2 - actualWidth / 2\n              };\n              break;\n          }\n\n          if (!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if (split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n              case 'left':\n                offset.left = position.left;\n                break;\n              case 'right':\n                offset.left = position.left + position.width - actualWidth;\n                break;\n              default:\n                break;\n            }\n          } else if (split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n              case 'top':\n                offset.top = position.top - actualHeight + position.height;\n                break;\n              case 'bottom':\n                offset.top = position.top;\n                break;\n              default:\n                break;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement (offset, placement) {\n          var tip = tipElement[0];\n          var width = tip.offsetWidth;\n          var height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10);\n          var marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth;\n          var actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement);\n            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;\n            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        // @source https://github.com/twbs/bootstrap/blob/v3.3.5/js/tooltip.js#L380\n        function getViewportAdjustedDelta (placement, position, actualWidth, actualHeight) {\n          var delta = {top: 0, left: 0};\n          if (!$tooltip.$viewport) return delta;\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0;\n          var viewportDimensions = getPosition($tooltip.$viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset = position.top - viewportPadding - viewportDimensions.scroll;\n            var bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset = position.left - viewportPadding;\n            var rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow (delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement () {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if ($tooltip.$isShown && tipElement !== null) {\n            if (options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if (options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if (tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if (tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest (scope) {\n        /* eslint-disable no-unused-expressions */\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n        /* eslint-enable no-unused-expressions */\n      }\n\n      function findElement (query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function ($window, $location, $sce, $parse, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n\n        var tooltip;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'titleTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function (newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }\n        });\n\n        attr.$observe('disabled', function (newValue) {\n          if (newValue && tooltip.$isShown) {\n            tooltip.hide();\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsTooltip) {\n          scope.$watch(attr.bsTooltip, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.title = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              $$rAF(function () {\n                if (tooltip) tooltip.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n            if (newValue === true) {\n              tooltip.show();\n            } else {\n              tooltip.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue, oldValue) {\n            // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n            if (newValue === false) {\n              tooltip.setEnabled(false);\n            } else {\n              tooltip.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!tooltip || !angular.isDefined(newValue)) return;\n            tooltip.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.timepicker', [ 'mgcrea.ngStrap.helpers.dateParser', 'mgcrea.ngStrap.helpers.dateFormatter', 'mgcrea.ngStrap.tooltip' ]).provider('$timepicker', function() {\n  var defaults = this.defaults = {\n    animation: 'am-fade',\n    defaultDate: 'auto',\n    prefixClass: 'timepicker',\n    placement: 'bottom-left',\n    templateUrl: 'timepicker/timepicker.tpl.html',\n    trigger: 'focus',\n    container: false,\n    keyboard: true,\n    html: false,\n    delay: 0,\n    useNative: true,\n    timeType: 'date',\n    timeFormat: 'shortTime',\n    timezone: null,\n    modelTimeFormat: null,\n    autoclose: false,\n    minTime: -Infinity,\n    maxTime: +Infinity,\n    length: 5,\n    hourStep: 1,\n    minuteStep: 5,\n    secondStep: 5,\n    roundDisplay: false,\n    iconUp: 'nox-sort-up',\n    iconDown: 'nox-sort-down',\n    arrowBehavior: 'pager'\n  };\n  this.$get = [ '$window', '$document', '$rootScope', '$sce', '$dateFormatter', '$tooltip', '$timeout', function($window, $document, $rootScope, $sce, $dateFormatter, $tooltip, $timeout) {\n    var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);\n    var isTouch = 'createTouch' in $window.document && isNative;\n    if (!defaults.lang) {\n      defaults.lang = $dateFormatter.getDefaultLocale();\n    }\n    function timepickerFactory(element, controller, config) {\n      var $timepicker = $tooltip(element, angular.extend({}, defaults, config));\n      var parentScope = config.scope;\n      var options = $timepicker.$options;\n      var scope = $timepicker.$scope;\n      var lang = options.lang;\n      var formatDate = function(date, format, timezone) {\n        return $dateFormatter.formatDate(date, format, lang, timezone);\n      };\n      function floorMinutes(time) {\n        var coeff = 1e3 * 60 * options.minuteStep;\n        return new Date(Math.floor(time.getTime() / coeff) * coeff);\n      }\n      var selectedIndex = 0;\n      var defaultDate = options.roundDisplay ? floorMinutes(new Date()) : new Date();\n      var startDate = controller.$dateValue || defaultDate;\n      var viewDate = {\n        hour: startDate.getHours(),\n        meridian: startDate.getHours() < 12,\n        minute: startDate.getMinutes(),\n        second: startDate.getSeconds(),\n        millisecond: startDate.getMilliseconds()\n      };\n      var format = $dateFormatter.getDatetimeFormat(options.timeFormat, lang);\n      var hoursFormat = $dateFormatter.hoursFormat(format);\n      var timeSeparator = $dateFormatter.timeSeparator(format);\n      var minutesFormat = $dateFormatter.minutesFormat(format);\n      var secondsFormat = $dateFormatter.secondsFormat(format);\n      var showSeconds = $dateFormatter.showSeconds(format);\n      var showAM = $dateFormatter.showAM(format);\n      scope.$iconUp = options.iconUp;\n      scope.$iconDown = options.iconDown;\n      scope.$select = function(date, index) {\n        $timepicker.select(date, index);\n      };\n      scope.$moveIndex = function(value, index) {\n        $timepicker.$moveIndex(value, index);\n      };\n      scope.$switchMeridian = function(date) {\n        $timepicker.switchMeridian(date);\n      };\n      $timepicker.update = function(date) {\n        if (angular.isDate(date) && !isNaN(date.getTime())) {\n          $timepicker.$date = date;\n          angular.extend(viewDate, {\n            hour: date.getHours(),\n            minute: date.getMinutes(),\n            second: date.getSeconds(),\n            millisecond: date.getMilliseconds()\n          });\n          $timepicker.$build();\n        } else if (!$timepicker.$isBuilt) {\n          $timepicker.$build();\n        }\n      };\n      $timepicker.select = function(date, index, keep) {\n        if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n          controller.$dateValue = options.defaultDate === 'today' ? new Date() : new Date(1970, 0, 1);\n        }\n        if (!angular.isDate(date)) date = new Date(date);\n        if (index === 0) controller.$dateValue.setHours(date.getHours()); else if (index === 1) controller.$dateValue.setMinutes(date.getMinutes()); else if (index === 2) controller.$dateValue.setSeconds(date.getSeconds());\n        controller.$setViewValue(angular.copy(controller.$dateValue));\n        controller.$render();\n        if (options.autoclose && !keep) {\n          $timeout(function() {\n            $timepicker.hide(true);\n          });\n        }\n      };\n      $timepicker.switchMeridian = function(date) {\n        if (!controller.$dateValue || isNaN(controller.$dateValue.getTime())) {\n          return;\n        }\n        var hours = (date || controller.$dateValue).getHours();\n        controller.$dateValue.setHours(hours < 12 ? hours + 12 : hours - 12);\n        controller.$setViewValue(angular.copy(controller.$dateValue));\n        controller.$render();\n      };\n      $timepicker.$build = function() {\n        var i;\n        var midIndex = scope.midIndex = parseInt(options.length / 2, 10);\n        var hours = [];\n        var hour;\n        for (i = 0; i < options.length; i++) {\n          hour = new Date(1970, 0, 1, viewDate.hour - (midIndex - i) * options.hourStep);\n          hours.push({\n            date: hour,\n            label: formatDate(hour, hoursFormat),\n            selected: $timepicker.$date && $timepicker.$isSelected(hour, 0),\n            disabled: $timepicker.$isDisabled(hour, 0)\n          });\n        }\n        var minutes = [];\n        var minute;\n        for (i = 0; i < options.length; i++) {\n          minute = new Date(1970, 0, 1, 0, viewDate.minute - (midIndex - i) * options.minuteStep);\n          minutes.push({\n            date: minute,\n            label: formatDate(minute, minutesFormat),\n            selected: $timepicker.$date && $timepicker.$isSelected(minute, 1),\n            disabled: $timepicker.$isDisabled(minute, 1)\n          });\n        }\n        var seconds = [];\n        var second;\n        for (i = 0; i < options.length; i++) {\n          second = new Date(1970, 0, 1, 0, 0, viewDate.second - (midIndex - i) * options.secondStep);\n          seconds.push({\n            date: second,\n            label: formatDate(second, secondsFormat),\n            selected: $timepicker.$date && $timepicker.$isSelected(second, 2),\n            disabled: $timepicker.$isDisabled(second, 2)\n          });\n        }\n        var rows = [];\n        for (i = 0; i < options.length; i++) {\n          if (showSeconds) {\n            rows.push([ hours[i], minutes[i], seconds[i] ]);\n          } else {\n            rows.push([ hours[i], minutes[i] ]);\n          }\n        }\n        scope.rows = rows;\n        scope.showSeconds = showSeconds;\n        scope.showAM = showAM;\n        scope.isAM = ($timepicker.$date || hours[midIndex].date).getHours() < 12;\n        scope.timeSeparator = timeSeparator;\n        $timepicker.$isBuilt = true;\n      };\n      $timepicker.$isSelected = function(date, index) {\n        if (!$timepicker.$date) return false; else if (index === 0) {\n          return date.getHours() === $timepicker.$date.getHours();\n        } else if (index === 1) {\n          return date.getMinutes() === $timepicker.$date.getMinutes();\n        } else if (index === 2) {\n          return date.getSeconds() === $timepicker.$date.getSeconds();\n        }\n      };\n      $timepicker.$isDisabled = function(date, index) {\n        var selectedTime;\n        if (index === 0) {\n          selectedTime = date.getTime() + viewDate.minute * 6e4 + viewDate.second * 1e3;\n        } else if (index === 1) {\n          selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.second * 1e3;\n        } else if (index === 2) {\n          selectedTime = date.getTime() + viewDate.hour * 36e5 + viewDate.minute * 6e4;\n        }\n        return selectedTime < options.minTime * 1 || selectedTime > options.maxTime * 1;\n      };\n      scope.$arrowAction = function(value, index) {\n        if (options.arrowBehavior === 'picker') {\n          $timepicker.$setTimeByStep(value, index);\n        } else {\n          $timepicker.$moveIndex(value, index);\n        }\n      };\n      $timepicker.$setTimeByStep = function(value, index) {\n        var newDate = new Date($timepicker.$date || startDate);\n        var hours = newDate.getHours();\n        var minutes = newDate.getMinutes();\n        var seconds = newDate.getSeconds();\n        if (index === 0) {\n          newDate.setHours(hours - parseInt(options.hourStep, 10) * value);\n        } else if (index === 1) {\n          newDate.setMinutes(minutes - parseInt(options.minuteStep, 10) * value);\n        } else if (index === 2) {\n          newDate.setSeconds(seconds - parseInt(options.secondStep, 10) * value);\n        }\n        $timepicker.select(newDate, index, true);\n      };\n      $timepicker.$moveIndex = function(value, index) {\n        var targetDate;\n        if (index === 0) {\n          targetDate = new Date(1970, 0, 1, viewDate.hour + value * options.length, viewDate.minute, viewDate.second);\n          angular.extend(viewDate, {\n            hour: targetDate.getHours()\n          });\n        } else if (index === 1) {\n          targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute + value * options.length * options.minuteStep, viewDate.second);\n          angular.extend(viewDate, {\n            minute: targetDate.getMinutes()\n          });\n        } else if (index === 2) {\n          targetDate = new Date(1970, 0, 1, viewDate.hour, viewDate.minute, viewDate.second + value * options.length * options.secondStep);\n          angular.extend(viewDate, {\n            second: targetDate.getSeconds()\n          });\n        }\n        $timepicker.$build();\n      };\n      $timepicker.$onMouseDown = function(evt) {\n        if (evt.target.nodeName.toLowerCase() !== 'input') evt.preventDefault();\n        evt.stopPropagation();\n        if (isTouch) {\n          var targetEl = angular.element(evt.target);\n          if (targetEl[0].nodeName.toLowerCase() !== 'button') {\n            targetEl = targetEl.parent();\n          }\n          targetEl.triggerHandler('click');\n        }\n      };\n      $timepicker.$onKeyDown = function(evt) {\n        if (!/(38|37|39|40|13)/.test(evt.keyCode) || evt.shiftKey || evt.altKey) return;\n        evt.preventDefault();\n        evt.stopPropagation();\n        if (evt.keyCode === 13) {\n          $timepicker.hide(true);\n          return;\n        }\n        var newDate = new Date($timepicker.$date);\n        var hours = newDate.getHours();\n        var hoursLength = formatDate(newDate, hoursFormat).length;\n        var minutes = newDate.getMinutes();\n        var minutesLength = formatDate(newDate, minutesFormat).length;\n        var seconds = newDate.getSeconds();\n        var secondsLength = formatDate(newDate, secondsFormat).length;\n        var sepLength = 1;\n        var lateralMove = /(37|39)/.test(evt.keyCode);\n        var count = 2 + showSeconds * 1 + showAM * 1;\n        if (lateralMove) {\n          if (evt.keyCode === 37) selectedIndex = selectedIndex < 1 ? count - 1 : selectedIndex - 1; else if (evt.keyCode === 39) selectedIndex = selectedIndex < count - 1 ? selectedIndex + 1 : 0;\n        }\n        var selectRange = [ 0, hoursLength ];\n        var incr = 0;\n        if (evt.keyCode === 38) incr = -1;\n        if (evt.keyCode === 40) incr = +1;\n        var isSeconds = selectedIndex === 2 && showSeconds;\n        var isMeridian = selectedIndex === 2 && !showSeconds || selectedIndex === 3 && showSeconds;\n        if (selectedIndex === 0) {\n          newDate.setHours(hours + incr * parseInt(options.hourStep, 10));\n          hoursLength = formatDate(newDate, hoursFormat).length;\n          selectRange = [ 0, hoursLength ];\n        } else if (selectedIndex === 1) {\n          newDate.setMinutes(minutes + incr * parseInt(options.minuteStep, 10));\n          minutesLength = formatDate(newDate, minutesFormat).length;\n          selectRange = [ hoursLength + sepLength, minutesLength ];\n        } else if (isSeconds) {\n          newDate.setSeconds(seconds + incr * parseInt(options.secondStep, 10));\n          secondsLength = formatDate(newDate, secondsFormat).length;\n          selectRange = [ hoursLength + sepLength + minutesLength + sepLength, secondsLength ];\n        } else if (isMeridian) {\n          if (!lateralMove) $timepicker.switchMeridian();\n          selectRange = [ hoursLength + sepLength + minutesLength + sepLength + (secondsLength + sepLength) * showSeconds, 2 ];\n        }\n        $timepicker.select(newDate, selectedIndex, true);\n        createSelection(selectRange[0], selectRange[1]);\n        parentScope.$digest();\n      };\n      function createSelection(start, length) {\n        var end = start + length;\n        if (element[0].createTextRange) {\n          var selRange = element[0].createTextRange();\n          selRange.collapse(true);\n          selRange.moveStart('character', start);\n          selRange.moveEnd('character', end);\n          selRange.select();\n        } else if (element[0].setSelectionRange) {\n          element[0].setSelectionRange(start, end);\n        } else if (angular.isUndefined(element[0].selectionStart)) {\n          element[0].selectionStart = start;\n          element[0].selectionEnd = end;\n        }\n      }\n      function focusElement() {\n        element[0].focus();\n      }\n      var _init = $timepicker.init;\n      $timepicker.init = function() {\n        if (isNative && options.useNative) {\n          element.prop('type', 'time');\n          element.css('-webkit-appearance', 'textfield');\n          return;\n        } else if (isTouch) {\n          element.prop('type', 'text');\n          element.attr('readonly', 'true');\n          element.on('click', focusElement);\n        }\n        _init();\n      };\n      var _destroy = $timepicker.destroy;\n      $timepicker.destroy = function() {\n        if (isNative && options.useNative) {\n          element.off('click', focusElement);\n        }\n        _destroy();\n      };\n      var _show = $timepicker.show;\n      $timepicker.show = function() {\n        if (!isTouch && element.attr('readonly') || element.attr('disabled')) return;\n        _show();\n        $timeout(function() {\n          if ($timepicker.$element) $timepicker.$element.on(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n          if (options.keyboard) {\n            if (element) element.on('keydown', $timepicker.$onKeyDown);\n          }\n        }, 0, false);\n      };\n      var _hide = $timepicker.hide;\n      $timepicker.hide = function(blur) {\n        if (!$timepicker.$isShown) return;\n        if ($timepicker.$element) $timepicker.$element.off(isTouch ? 'touchstart' : 'mousedown', $timepicker.$onMouseDown);\n        if (options.keyboard) {\n          if (element) element.off('keydown', $timepicker.$onKeyDown);\n        }\n        _hide(blur);\n      };\n      return $timepicker;\n    }\n    timepickerFactory.defaults = defaults;\n    return timepickerFactory;\n  } ];\n}).directive('bsTimepicker', [ '$window', '$parse', '$q', '$dateFormatter', '$dateParser', '$timepicker', function($window, $parse, $q, $dateFormatter, $dateParser, $timepicker) {\n  var defaults = $timepicker.defaults;\n  var isNative = /(ip[ao]d|iphone|android)/gi.test($window.navigator.userAgent);\n  return {\n    restrict: 'EAC',\n    require: 'ngModel',\n    link: function postLink(scope, element, attr, controller) {\n      var options = {\n        scope: scope\n      };\n      angular.forEach([ 'template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'autoclose', 'timeType', 'timeFormat', 'timezone', 'modelTimeFormat', 'useNative', 'hourStep', 'minuteStep', 'secondStep', 'length', 'arrowBehavior', 'iconUp', 'iconDown', 'roundDisplay', 'id', 'prefixClass', 'prefixEvent', 'defaultDate' ], function(key) {\n        if (angular.isDefined(attr[key])) options[key] = attr[key];\n      });\n      var falseValueRegExp = /^(false|0|)$/i;\n      angular.forEach([ 'html', 'container', 'autoclose', 'useNative', 'roundDisplay' ], function(key) {\n        if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n          options[key] = false;\n        }\n      });\n      angular.forEach([ 'onBeforeShow', 'onShow', 'onBeforeHide', 'onHide' ], function(key) {\n        var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n        if (angular.isDefined(attr[bsKey])) {\n          options[key] = scope.$eval(attr[bsKey]);\n        }\n      });\n      if (isNative && (options.useNative || defaults.useNative)) options.timeFormat = 'HH:mm';\n      var timepicker = $timepicker(element, controller, options);\n      options = timepicker.$options;\n      var lang = options.lang;\n      var formatDate = function(date, format, timezone) {\n        return $dateFormatter.formatDate(date, format, lang, timezone);\n      };\n      if (attr.bsShow) {\n        scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if (!timepicker || !angular.isDefined(newValue)) return;\n          if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(timepicker),?/i);\n          if (newValue === true) {\n            timepicker.show();\n          } else {\n            timepicker.hide();\n          }\n        });\n      }\n      var dateParser = $dateParser({\n        format: options.timeFormat,\n        lang: lang\n      });\n      angular.forEach([ 'minTime', 'maxTime' ], function(key) {\n        if (angular.isDefined(attr[key])) {\n          attr.$observe(key, function(newValue) {\n            timepicker.$options[key] = dateParser.getTimeForAttribute(key, newValue);\n            if (!isNaN(timepicker.$options[key])) timepicker.$build();\n            validateAgainstMinMaxTime(controller.$dateValue);\n          });\n        }\n      });\n      scope.$watch(attr.ngModel, function(newValue, oldValue) {\n        timepicker.update(controller.$dateValue);\n      }, true);\n      function validateAgainstMinMaxTime(parsedTime) {\n        if (!angular.isDate(parsedTime)) return;\n        var isMinValid = isNaN(options.minTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) >= options.minTime;\n        var isMaxValid = isNaN(options.maxTime) || new Date(parsedTime.getTime()).setFullYear(1970, 0, 1) <= options.maxTime;\n        var isValid = isMinValid && isMaxValid;\n        controller.$setValidity('date', isValid);\n        controller.$setValidity('min', isMinValid);\n        controller.$setValidity('max', isMaxValid);\n        if (!isValid) {\n          return;\n        }\n        controller.$dateValue = parsedTime;\n      }\n      controller.$parsers.unshift(function(viewValue) {\n        var date;\n        if (!viewValue) {\n          controller.$setValidity('date', true);\n          return null;\n        }\n        var parsedTime = angular.isDate(viewValue) ? viewValue : dateParser.parse(viewValue, controller.$dateValue);\n        if (!parsedTime || isNaN(parsedTime.getTime())) {\n          controller.$setValidity('date', false);\n          return undefined;\n        }\n        validateAgainstMinMaxTime(parsedTime);\n        if (options.timeType === 'string') {\n          date = dateParser.timezoneOffsetAdjust(parsedTime, options.timezone, true);\n          return formatDate(date, options.modelTimeFormat || options.timeFormat);\n        }\n        date = dateParser.timezoneOffsetAdjust(controller.$dateValue, options.timezone, true);\n        if (options.timeType === 'number') {\n          return date.getTime();\n        } else if (options.timeType === 'unix') {\n          return date.getTime() / 1e3;\n        } else if (options.timeType === 'iso') {\n          return date.toISOString();\n        }\n        return new Date(date);\n      });\n      controller.$formatters.push(function(modelValue) {\n        var date;\n        if (angular.isUndefined(modelValue) || modelValue === null) {\n          date = NaN;\n        } else if (angular.isDate(modelValue)) {\n          date = modelValue;\n        } else if (options.timeType === 'string') {\n          date = dateParser.parse(modelValue, null, options.modelTimeFormat);\n        } else if (options.timeType === 'unix') {\n          date = new Date(modelValue * 1e3);\n        } else {\n          date = new Date(modelValue);\n        }\n        controller.$dateValue = dateParser.timezoneOffsetAdjust(date, options.timezone);\n        return getTimeFormattedString();\n      });\n      controller.$render = function() {\n        element.val(getTimeFormattedString());\n      };\n      function getTimeFormattedString() {\n        return !controller.$dateValue || isNaN(controller.$dateValue.getTime()) ? '' : formatDate(controller.$dateValue, options.timeFormat);\n      }\n      scope.$on('$destroy', function() {\n        if (timepicker) timepicker.destroy();\n        options = null;\n        timepicker = null;\n      });\n    }\n  };\n} ]);\n","'use strict';\n\nangular.module('mgcrea.ngStrap.sort', []).directive('bsSort', [function() {\n  return {\n    scope: true,\n    compile: function(element, attrs) {\n      var list = element[0].querySelectorAll('th');\n      for (var i = 0, len = list.length; i < len; i++) {\n        var item = list[i];\n        item = angular.element(item);\n        if (item.attr('data-sortable')) {\n          var dataName = item.attr('data-name');\n          item.append('<div class=\"sorter\"><i class=\"nox-sort-up sort-asc\" ng-class=\"{active: orderBy == \\'' + dataName + '\\' && sortBy == \\'asc\\'}\"></i><i class=\"nox-sort-down sort-desc\" ng-class=\"{active: orderBy == \\'' + dataName + '\\' && sortBy == \\'desc\\'}\"></i></div>');\n        }\n      }\n\n      return function postLink (scope, element, attrs) {\n        var options = {\n          scope: scope,\n          element: element,\n          show: false\n        };\n        angular.forEach(['onSort'], function(key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attrs[bsKey])) {\n            options[key] = scope.$eval(attrs[bsKey]);\n          }\n        });\n        var list = element[0].querySelectorAll('th');\n        for (var i = 0, len = list.length; i < len; i++) {\n          var item = list[i];\n          item = angular.element(item);\n          if (item.attr('data-sortable')) {\n            item.on('click', clickColumn)\n          }\n        }\n\n        function clickColumn(event) {\n          var target = angular.element(event.currentTarget);\n          var dataName = target.attr('data-name');\n          if (dataName === scope.orderBy) {\n            scope.sortBy = scope.sortBy === 'asc' ? 'desc' : 'asc';\n          }\n          else {\n            scope.orderBy = dataName;\n            scope.sortBy = 'asc';\n          }\n          scope.$apply();\n\n          if (angular.isDefined(options.onSort) && angular.isFunction(options.onSort)) {\n            options.onSort(scope.orderBy, scope.sortBy);\n          }\n        }\n\n      }\n\n    }\n  };\n} ]);\n","'use strict';\n\nangular.module('mgcrea.ngStrap.tab', []).provider('$tab', function() {\n  var defaults = this.defaults = {\n    animation: 'am-fade',\n    template: 'tab/tab.tpl.html',\n    navClass: 'nav-tabs',\n    activeClass: 'active'\n  };\n  var controller = this.controller = function($scope, $element, $attrs) {\n    var self = this;\n    self.$options = angular.copy(defaults);\n    angular.forEach([ 'animation', 'navClass', 'activeClass' ], function(key) {\n      if (angular.isDefined($attrs[key])) self.$options[key] = $attrs[key];\n    });\n    $scope.$navClass = self.$options.navClass;\n    $scope.$activeClass = self.$options.activeClass;\n    self.$panes = $scope.$panes = [];\n    self.$activePaneChangeListeners = self.$viewChangeListeners = [];\n    self.$push = function(pane) {\n      if (angular.isUndefined(self.$panes.$active)) {\n        $scope.$setActive(pane.name || 0);\n      }\n      self.$panes.push(pane);\n    };\n    self.$remove = function(pane) {\n      var index = self.$panes.indexOf(pane);\n      var active = self.$panes.$active;\n      var activeIndex;\n      if (angular.isString(active)) {\n        activeIndex = self.$panes.map(function(pane) {\n          return pane.name;\n        }).indexOf(active);\n      } else {\n        activeIndex = self.$panes.$active;\n      }\n      self.$panes.splice(index, 1);\n      if (index < activeIndex) {\n        activeIndex--;\n      } else if (index === activeIndex && activeIndex === self.$panes.length) {\n        activeIndex--;\n      }\n      if (activeIndex >= 0 && activeIndex < self.$panes.length) {\n        self.$setActive(self.$panes[activeIndex].name || activeIndex);\n      } else {\n        self.$setActive();\n      }\n    };\n    self.$setActive = $scope.$setActive = function(value) {\n      self.$panes.$active = value;\n      self.$activePaneChangeListeners.forEach(function(fn) {\n        fn();\n      });\n    };\n    self.$isActive = $scope.$isActive = function($pane, $index) {\n      return self.$panes.$active === $pane.name || self.$panes.$active === $index;\n    };\n  };\n  this.$get = function() {\n    var $tab = {};\n    $tab.defaults = defaults;\n    $tab.controller = controller;\n    return $tab;\n  };\n}).directive('bsTabs', [ '$window', '$animate', '$tab', '$parse', function($window, $animate, $tab, $parse) {\n  var defaults = $tab.defaults;\n  return {\n    require: [ '?ngModel', 'bsTabs' ],\n    transclude: true,\n    scope: true,\n    controller: [ '$scope', '$element', '$attrs', $tab.controller ],\n    templateUrl: function(element, attr) {\n      return attr.template || defaults.template;\n    },\n    link: function postLink(scope, element, attrs, controllers) {\n      var ngModelCtrl = controllers[0];\n      var bsTabsCtrl = controllers[1];\n      if (ngModelCtrl) {\n        bsTabsCtrl.$activePaneChangeListeners.push(function() {\n          ngModelCtrl.$setViewValue(bsTabsCtrl.$panes.$active);\n        });\n        ngModelCtrl.$formatters.push(function(modelValue) {\n          bsTabsCtrl.$setActive(modelValue);\n          return modelValue;\n        });\n      }\n      if (attrs.bsActivePane) {\n        var parsedBsActivePane = $parse(attrs.bsActivePane);\n        bsTabsCtrl.$activePaneChangeListeners.push(function() {\n          parsedBsActivePane.assign(scope, bsTabsCtrl.$panes.$active);\n        });\n        scope.$watch(attrs.bsActivePane, function(newValue, oldValue) {\n          bsTabsCtrl.$setActive(newValue);\n        }, true);\n      }\n    }\n  };\n} ]).directive('bsPane', [ '$window', '$animate', '$sce', function($window, $animate, $sce) {\n  return {\n    require: [ '^?ngModel', '^bsTabs' ],\n    scope: true,\n    link: function postLink(scope, element, attrs, controllers) {\n      var bsTabsCtrl = controllers[1];\n      element.addClass('tab-pane');\n      attrs.$observe('title', function(newValue, oldValue) {\n        scope.title = $sce.trustAsHtml(newValue);\n      });\n      scope.name = attrs.name;\n      scope.link = attrs.link ? attrs.link : false;\n      if (bsTabsCtrl.$options.animation) {\n        element.addClass(bsTabsCtrl.$options.animation);\n      }\n      attrs.$observe('disabled', function(newValue, oldValue) {\n        scope.disabled = scope.$eval(newValue);\n      });\n      bsTabsCtrl.$push(scope);\n      scope.$on('$destroy', function() {\n        bsTabsCtrl.$remove(scope);\n      });\n      function render() {\n        var index = bsTabsCtrl.$panes.indexOf(scope);\n        $animate[bsTabsCtrl.$isActive(scope, index) ? 'addClass' : 'removeClass'](element, bsTabsCtrl.$options.activeClass);\n      }\n      bsTabsCtrl.$activePaneChangeListeners.push(function() {\n        render();\n      });\n      render();\n    }\n  };\n} ]);\n","'use strict';\n\nangular.module('mgcrea.ngStrap.popover', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$popover', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      // uncommenting the next two lines will break backwards compatability\n      // prefixClass: 'popover',\n      // prefixEvent: 'popover',\n      container: false,\n      target: false,\n      placement: 'right',\n      templateUrl: 'popover/popover.tpl.html',\n      contentTemplate: false,\n      trigger: 'click',\n      keyboard: true,\n      html: false,\n      title: '',\n      content: '',\n      delay: 0,\n      autoClose: false\n    };\n\n    this.$get = function ($tooltip) {\n\n      function PopoverFactory (element, config) {\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        var $popover = $tooltip(element, options);\n\n        // Support scope as string options [/*title, */content]\n        if (options.content) {\n          $popover.$scope.content = options.content;\n        }\n\n        return $popover;\n\n      }\n\n      return PopoverFactory;\n\n    };\n\n  })\n\n  .directive('bsPopover', function ($window, $sce, $popover) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame || $window.setTimeout;\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr) {\n\n        var popover;\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'customClass', 'autoClose', 'id', 'prefixClass', 'prefixEvent', 'bsEnabled'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'autoClose'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if (angular.isDefined(dataTarget)) {\n          if (falseValueRegExp.test(dataTarget)) {\n            options.target = false;\n          } else {\n            options.target = dataTarget;\n          }\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n              if (angular.isDefined(oldValue)) {\n                requestAnimationFrame(function () {\n                  if (popover) popover.$applyPlacement();\n                });\n              }\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsPopover) {\n          scope.$watch(attr.bsPopover, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n            if (angular.isDefined(oldValue)) {\n              requestAnimationFrame(function () {\n                if (popover) popover.$applyPlacement();\n              });\n            }\n          }, true);\n        }\n\n        // Visibility binding support\n        if (attr.bsShow) {\n          scope.$watch(attr.bsShow, function (newValue, oldValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(popover),?/i);\n            if (newValue === true) {\n              popover.show();\n            } else {\n              popover.hide();\n            }\n          });\n        }\n\n        // Enabled binding support\n        if (attr.bsEnabled) {\n          scope.$watch(attr.bsEnabled, function (newValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            if (angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(popover),?/i);\n            if (newValue === false) {\n              popover.setEnabled(false);\n            } else {\n              popover.setEnabled(true);\n            }\n          });\n        }\n\n        // Viewport support\n        if (attr.viewport) {\n          scope.$watch(attr.viewport, function (newValue) {\n            if (!popover || !angular.isDefined(newValue)) return;\n            popover.setViewport(newValue);\n          });\n        }\n\n        // Initialize popover\n        popover = $popover(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (popover) popover.destroy();\n          options = null;\n          popover = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.select', ['mgcrea.ngStrap.tooltip', 'mgcrea.ngStrap.helpers.parseOptions'])\n\n  .provider('$select', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'select',\n      prefixEvent: '$select',\n      placement: 'bottom-left',\n      templateUrl: 'select/select.tpl.html',\n      trigger: 'focus',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0,\n      multiple: false,\n      allNoneButtons: false,\n      sort: true,\n      caretHtml: '&nbsp;<span class=\"caret\"></span>',\n      placeholder: 'Choose among the following...',\n      allText: 'All',\n      noneText: 'None',\n      maxLength: 3,\n      maxLengthHtml: 'selected',\n      iconCheckmark: 'glyphicon glyphicon-ok',\n      toggle: false\n    };\n\n    this.$get = function ($window, $document, $rootScope, $tooltip, $timeout) {\n\n      // var bodyEl = angular.element($window.document.body);\n      var isNative = /(ip[ao]d|iphone|android)/ig.test($window.navigator.userAgent);\n      var isTouch = ('createTouch' in $window.document) && isNative;\n\n      function SelectFactory (element, controller, config) {\n\n        var $select = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $select = $tooltip(element, options);\n        var scope = $select.$scope;\n\n        scope.$matches = [];\n        if (options.multiple) {\n          scope.$activeIndex = [];\n        } else {\n          scope.$activeIndex = -1;\n        }\n        scope.$isMultiple = options.multiple;\n        scope.$showAllNoneButtons = options.allNoneButtons && options.multiple;\n        scope.$iconCheckmark = options.iconCheckmark;\n        scope.$allText = options.allText;\n        scope.$noneText = options.noneText;\n\n        scope.$activate = function (index) {\n          scope.$$postDigest(function () {\n            $select.activate(index);\n          });\n        };\n\n        scope.$select = function (index, evt) {\n          scope.$$postDigest(function () {\n            $select.select(index);\n          });\n        };\n\n        scope.$isVisible = function () {\n          return $select.$isVisible();\n        };\n\n        scope.$isActive = function (index) {\n          return $select.$isActive(index);\n        };\n\n        scope.$selectAll = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (!scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        scope.$selectNone = function () {\n          for (var i = 0; i < scope.$matches.length; i++) {\n            if (scope.$isActive(i)) {\n              scope.$select(i);\n            }\n          }\n        };\n\n        // Public methods\n\n        $select.update = function (matches) {\n          scope.$matches = matches;\n          $select.$updateActiveIndex();\n        };\n\n        $select.activate = function (index) {\n          if (options.multiple) {\n            if ($select.$isActive(index)) {\n              scope.$activeIndex.splice(scope.$activeIndex.indexOf(index), 1);\n            } else {\n              scope.$activeIndex.push(index);\n            }\n            if (options.sort) scope.$activeIndex.sort(function (a, b) { return a - b; }); // use numeric sort instead of default sort\n          } else {\n            scope.$activeIndex = index;\n          }\n          return scope.$activeIndex;\n        };\n\n        $select.select = function (index) {\n          if (angular.isUndefined(index) || index < 0 || index >= scope.$matches.length) { return; }\n          var value = scope.$matches[index].value;\n          scope.$apply(function () {\n            $select.activate(index);\n            if (options.multiple) {\n              controller.$setViewValue(scope.$activeIndex.map(function (index) {\n                if (angular.isUndefined(scope.$matches[index])) {\n                  return null;\n                }\n                return scope.$matches[index].value;\n              }));\n            } else {\n              if (options.toggle) {\n                controller.$setViewValue((value === controller.$modelValue) ? undefined : value);\n              } else {\n                controller.$setViewValue(value);\n              }\n              // Hide if single select\n              $select.hide();\n            }\n          });\n          // Emit event\n          scope.$emit(options.prefixEvent + '.select', value, index, $select);\n          if (angular.isDefined(options.onSelect) && angular.isFunction(options.onSelect)) {\n            options.onSelect(value, index, $select);\n          }\n        };\n\n        // Protected methods\n\n        $select.$updateActiveIndex = function () {\n          if (options.multiple) {\n            if (angular.isArray(controller.$modelValue)) {\n              scope.$activeIndex = controller.$modelValue.map(function (value) {\n                return $select.$getIndex(value);\n              });\n            } else {\n              scope.$activeIndex = [];\n            }\n          } else {\n            if (angular.isDefined(controller.$modelValue) && scope.$matches.length) {\n              scope.$activeIndex = $select.$getIndex(controller.$modelValue);\n            } else {\n              scope.$activeIndex = -1;\n            }\n          }\n        };\n\n        $select.$isVisible = function () {\n          if (!options.minLength || !controller) {\n            return scope.$matches.length;\n          }\n          // minLength support\n          return scope.$matches.length && controller.$viewValue.length >= options.minLength;\n        };\n\n        $select.$isActive = function (index) {\n          if (options.multiple) {\n            return scope.$activeIndex.indexOf(index) !== -1;\n          }\n          return scope.$activeIndex === index;\n        };\n\n        $select.$getIndex = function (value) {\n          var index;\n          for (index = scope.$matches.length; index--;) {\n            if (angular.equals(scope.$matches[index].value, value)) break;\n          }\n          return index;\n        };\n\n        $select.$onMouseDown = function (evt) {\n          // Prevent blur on mousedown on .dropdown-menu\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Emulate click for mobile devices\n          if (isTouch) {\n            var targetEl = angular.element(evt.target);\n            var anchor;\n\n            if (evt.target.nodeName !== 'A') {\n              var anchorCandidate = targetEl.parent();\n              while (!anchor && anchorCandidate.length > 0) {\n                if (anchorCandidate[0].nodeName === 'A') {\n                  anchor = anchorCandidate;\n                }\n                anchorCandidate = anchorCandidate.parent();\n              }\n            }\n\n            if (anchor) {\n              angular.element(anchor).triggerHandler('click');\n            } else {\n              targetEl.triggerHandler('click');\n            }\n          }\n        };\n\n        $select.$onKeyDown = function (evt) {\n          if (!/(9|13|38|40)/.test(evt.keyCode)) return;\n          // Let tab propagate\n          if (evt.keyCode !== 9) {\n            evt.preventDefault();\n            evt.stopPropagation();\n          }\n\n          // release focus on tab\n          if (options.multiple && evt.keyCode === 9) {\n            return $select.hide();\n          }\n\n          // Select with enter\n          if (!options.multiple && (evt.keyCode === 13 || evt.keyCode === 9)) {\n            return $select.select(scope.$activeIndex);\n          }\n\n          if (!options.multiple) {\n            // Navigate with keyboard\n            if (evt.keyCode === 38 && scope.$activeIndex > 0) scope.$activeIndex--;\n            else if (evt.keyCode === 38 && scope.$activeIndex < 0) scope.$activeIndex = scope.$matches.length - 1;\n            else if (evt.keyCode === 40 && scope.$activeIndex < scope.$matches.length - 1) scope.$activeIndex++;\n            else if (angular.isUndefined(scope.$activeIndex)) scope.$activeIndex = 0;\n            scope.$digest();\n          }\n        };\n\n        $select.$isIE = function () {\n          var ua = $window.navigator.userAgent;\n          return ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0;\n        };\n\n        $select.$selectScrollFix = function (e) {\n          if ($document[0].activeElement.tagName === 'UL') {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            e.target.focus();\n          }\n        };\n\n        // Overrides\n\n        var _show = $select.show;\n        $select.show = function () {\n          _show();\n          if (options.multiple) {\n            $select.$element.addClass('select-multiple');\n          }\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            $select.$element.on(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n            if (options.keyboard) {\n              element.on('keydown', $select.$onKeyDown);\n            }\n          }, 0, false);\n        };\n\n        var _hide = $select.hide;\n        $select.hide = function () {\n          if (!options.multiple && angular.isUndefined(controller.$modelValue)) {\n            scope.$activeIndex = -1;\n          }\n          $select.$element.off(isTouch ? 'touchstart' : 'mousedown', $select.$onMouseDown);\n          if (options.keyboard) {\n            element.off('keydown', $select.$onKeyDown);\n          }\n          _hide(true);\n        };\n\n        return $select;\n\n      }\n\n      SelectFactory.defaults = defaults;\n      return SelectFactory;\n\n    };\n\n  })\n\n  .directive('bsSelect', function ($window, $parse, $q, $select, $parseOptions) {\n\n    var defaults = $select.defaults;\n\n    return {\n      restrict: 'EAC',\n      require: 'ngModel',\n      link: function postLink (scope, element, attr, controller) {\n\n        // Directive options\n        var options = {scope: scope, placeholder: defaults.placeholder};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'placeholder', 'allNoneButtons', 'maxLength', 'maxLengthHtml', 'allText', 'noneText', 'iconCheckmark', 'autoClose', 'id', 'sort', 'caretHtml', 'prefixClass', 'prefixEvent', 'toggle'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container', 'allNoneButtons', 'sort'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) {\n            options[key] = false;\n          }\n        });\n\n        // bind functions from the attrs to the show, hide and select events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide', 'onSelect'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // Only parse data-multiple. Angular sets existence attributes to true (multiple/required/etc), they apply this\n        // to data-multiple as well for some reason, so we'll parse this ourselves and disregard multiple\n        var dataMultiple = element.attr('data-multiple');\n        if (angular.isDefined(dataMultiple)) {\n          if (falseValueRegExp.test(dataMultiple)) {\n            options.multiple = false;\n          } else {\n            options.multiple = dataMultiple;\n          }\n        }\n\n        // Add support for select markup\n        if (element[0].nodeName.toLowerCase() === 'select') {\n          var inputEl = element;\n          inputEl.css('display', 'none');\n          element = angular.element('<button type=\"button\" class=\"btn btn-default\"></button>');\n          inputEl.after(element);\n        }\n\n        // Build proper bsOptions\n        var parsedOptions = $parseOptions(attr.bsOptions);\n\n        // Initialize select\n        var select = $select(element, controller, options);\n\n        if (select.$isIE()) {\n          element[0].addEventListener('blur', select.$selectScrollFix);\n        }\n\n        // Watch bsOptions values before filtering for changes\n        var watchedOptions = parsedOptions.$match[7].replace(/\\|.+/, '').trim();\n        scope.$watch(watchedOptions, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', watchedOptions, newValue, oldValue);\n          parsedOptions.valuesFn(scope, controller)\n          .then(function (values) {\n            select.update(values);\n            controller.$render();\n          });\n        }, true);\n\n        // Watch model for changes\n        scope.$watch(attr.ngModel, function (newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.ngModel, newValue, oldValue);\n          select.$updateActiveIndex();\n          controller.$render();\n        }, true);\n\n        // Model rendering in view\n        controller.$render = function () {\n          // console.warn('$render', element.attr('ng-model'), 'controller.$modelValue', typeof controller.$modelValue, controller.$modelValue, 'controller.$viewValue', typeof controller.$viewValue, controller.$viewValue);\n          var selected;\n          var index;\n          if (options.multiple && angular.isArray(controller.$modelValue)) {\n            selected = controller.$modelValue.map(function (value) {\n              index = select.$getIndex(value);\n              return index !== -1 ? select.$scope.$matches[index].label : false;\n            }).filter(angular.isDefined);\n            if (selected.length > (options.maxLength || defaults.maxLength)) {\n              selected = selected.length + ' ' + (options.maxLengthHtml || defaults.maxLengthHtml);\n            } else {\n              selected = selected.join(', ');\n            }\n          } else {\n            index = select.$getIndex(controller.$modelValue);\n            selected = index !== -1 ? select.$scope.$matches[index].label : false;\n          }\n          element.html((selected || options.placeholder) + (options.caretHtml || defaults.caretHtml));\n        };\n\n        if (options.multiple) {\n          controller.$isEmpty = function (value) {\n            return !value || value.length === 0;\n          };\n        }\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (select) select.destroy();\n          options = null;\n          select = null;\n        });\n\n      }\n    };\n\n  });\n","'use strict';\n// 1, 2, 3 ... 10\n// 1 ... 8, 9, 10\n// 1 ... 5, 6, 7 ... 10\nangular.module('mgcrea.ngStrap.pagination', [])\n  .provider('$pagination', function() {\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      pageClass: 'pagination',\n      pagesLength: 5,\n      itemsPerPage: 20,\n      templateUrl: 'pagination/pagination.tpl.html'\n    };\n\n    var controller = this.controller = function($scope, $element, $attrs) {\n      /**\n       * \n       * @returns {number}\n       */\n      this.calculateTotalPages = function(itemsPerPage, totalItems) {\n        var totalPages = itemsPerPage < 1\n          ? 1\n          : Math.ceil(totalItems / itemsPerPage);\n        return Math.max(totalPages || 0, 1);\n      };\n\n      this.makePage = function (number, text, isActive) {\n        return {\n          number: number,\n          text: text,\n          active: isActive\n        };\n      };\n\n      /**\n       * \n       * @param currentPage \n       * @param totalPages  \n       * @param pagesLength \n       * @returns {Array}\n       */\n      this.getPages = function (currentPage, totalPages, pagesLength) {\n        // \n        currentPage = currentPage < 1\n          ? 1\n          : ((totalPages > 0 && currentPage > totalPages) ? totalPages : currentPage);\n\n        var pages = [];\n        var i;\n\n        if (totalPages <= pagesLength) {\n          for (i = 1; i <= totalPages; i++){\n            pages.push(this.makePage(i, i, i === currentPage));\n          }\n        }\n        else { // 1....2....3....\n          // \n          var offset = (pagesLength - 1) / 2;\n          if (currentPage <= offset) {\n            // ...\n            for (i = 1; i <= offset + 1; i++){\n              pages.push(this.makePage(i, i, i === currentPage));\n            }\n            pages.push(this.makePage(i + 1, '...', false));\n            pages.push(this.makePage(totalPages, totalPages, false));\n          }\n          else if (currentPage > totalPages - offset) {\n            pages.push(this.makePage(1, 1, false));\n            pages.push(this.makePage(totalPages - offset - 1, '...', false));\n            for(i = offset; i >= 0; i--){\n              var p = totalPages - i;\n              pages.push(this.makePage(p, p, p === currentPage));\n            }\n          }\n          else {\n            // ...\n            pages.push(this.makePage(1, 1, false));\n            // \n            var half = Math.ceil(offset / 2);\n            pages.push(this.makePage(currentPage - half - 1, '...', false));\n            for(i = half; i >= 1; i--){\n              pages.push(this.makePage(currentPage - i, currentPage - i, false));\n            }\n            pages.push(this.makePage(currentPage, currentPage, true));\n            for(i = 1; i <= half; i++){\n              pages.push(this.makePage(currentPage + i, currentPage + i, false));\n            }\n            pages.push(this.makePage(currentPage + half + 1, '...', false));\n            pages.push(this.makePage(totalPages, totalPages, false));\n          }\n        }\n        return pages;\n      };\n    };\n    this.$get = function() {\n      var $pagination = {};\n      $pagination.defaults = defaults;\n      $pagination.controller = controller;\n      return $pagination;\n    };\n  })\n  .directive('bsPagination', [ '$window', '$sce', '$parse', '$pagination', function($window, $sce, $parse, $pagination) {\n    var defaults = $pagination.defaults;\n    return {\n      restrict: 'E',\n      require: [ '?ngModel', 'bsPagination' ],\n      scope: true,\n      replace: true,\n      controller: ['$scope', '$element', '$attrs', $pagination.controller],\n      templateUrl: function (element, attr) {\n        return attr.template || defaults.templateUrl;\n      },\n      link: function postLink(scope, element, attrs, controllers) {\n        var ngModelCtrl = controllers[0];\n        var bsPaginationCtrl = controllers[1];\n\n        if (!ngModelCtrl) {\n          return;\n        }\n\n        var options = angular.copy(defaults);\n\n        // \n        angular.forEach(['pageClass', 'pagesLength', 'itemsPerPage'], function (key) {\n          if (angular.isDefined(attrs[key])) {\n            options[key] = scope.$eval(attrs[key]);\n          }\n        });\n        angular.forEach(['onChange'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attrs[bsKey])) {\n            options[key] = scope.$eval(attrs[bsKey]);\n          }\n        });\n        // totalItemsloadingno result\n        if (attrs['totalItems']) {\n          attrs.$observe('totalItems', function (newValue, oldValue) {\n            scope.totalItems = newValue;\n            scope.totalPages = bsPaginationCtrl.calculateTotalPages(options.itemsPerPage, scope.totalItems);\n            ngModelCtrl.$render();\n          });\n        }\n\n        scope.$pageClass = options.pageClass;\n        // pageLength\n        if (options.pagesLength % 2 === 0) {\n          options.pagesLength = options.pagesLength + 1;\n        }\n\n        /**\n         * modelpage\n         */\n        ngModelCtrl.$render = function () {\n          scope.page = (parseInt(ngModelCtrl.$viewValue, 10) || 1) > scope.totalPages ? scope.totalPages : scope.page;\n          if (scope.page > 0 && scope.page <= scope.totalPages) {\n            scope.pages = bsPaginationCtrl.getPages(scope.page, scope.totalPages, options.pagesLength);\n          }\n        };\n\n        /**\n         * \n         * @param page\n         * @param evt\n         */\n        scope.selectPage = function (page, evt) {\n          if (evt) {\n            evt.preventDefault();\n          }\n          if (scope.page !== page && page > 0 && page <= scope.totalPages) {\n            if (evt && evt.target) {\n              evt.target.blur();\n            }\n            // \n            ngModelCtrl.$setViewValue(page);\n            ngModelCtrl.$render();\n\n            if (angular.isDefined(options.onChange) && angular.isFunction(options.onChange)) {\n              // observe\n              options.onChange();\n            }\n          }\n        };\n\n        scope.noPrevious = function () {\n          return scope.page === 1;\n        };\n\n        scope.noNext = function () {\n          return scope.page === scope.totalPages;\n        };\n\n        scope.selectPrevious = function (evt) {\n          scope.selectPage(scope.page - 1, evt);\n        };\n\n        scope.selectNext = function (evt) {\n          scope.selectPage(scope.page + 1, evt);\n        };\n      }\n    };\n  }]);\n","'use strict';\n\nif (angular.version.minor < 3 && angular.version.dot < 14) {\n  angular.module('ng')\n\n  .factory('$$rAF', function ($window, $timeout) {\n\n    var requestAnimationFrame = $window.requestAnimationFrame ||\n                                $window.webkitRequestAnimationFrame ||\n                                $window.mozRequestAnimationFrame;\n\n    var cancelAnimationFrame = $window.cancelAnimationFrame ||\n                               $window.webkitCancelAnimationFrame ||\n                               $window.mozCancelAnimationFrame ||\n                               $window.webkitCancelRequestAnimationFrame;\n\n    var rafSupported = !!requestAnimationFrame;\n    var raf = rafSupported ?\n      function (fn) {\n        var id = requestAnimationFrame(fn);\n        return function () {\n          cancelAnimationFrame(id);\n        };\n      } :\n      function (fn) {\n        var timer = $timeout(fn, 16.66, false); // 1000 / 60 = 16.666\n        return function () {\n          $timeout.cancel(timer);\n        };\n      };\n\n    raf.supported = rafSupported;\n\n    return raf;\n\n  });\n}\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.parseOptions', [])\n\n  .provider('$parseOptions', function () {\n\n    var defaults = this.defaults = {\n      regexp: /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/\n    };\n\n    this.$get = function ($parse, $q) {\n\n      function ParseOptionsFactory (attr, config) {\n\n        var $parseOptions = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        $parseOptions.$values = [];\n\n        // Private vars\n        var match;\n        var displayFn;\n        var valueName;\n        /* eslint-disable no-unused-vars */\n        var keyName;\n        var groupByFn;\n        /* eslint-enable no-unused-vars */\n        var valueFn;\n        var valuesFn;\n\n        $parseOptions.init = function () {\n          $parseOptions.$match = match = attr.match(options.regexp);\n          displayFn = $parse(match[2] || match[1]);\n          valueName = match[4] || match[6];\n          keyName = match[5];\n          groupByFn = $parse(match[3] || '');\n          valueFn = $parse(match[2] ? match[1] : valueName);\n          valuesFn = $parse(match[7]);\n        };\n\n        $parseOptions.valuesFn = function (scope, controller) {\n          return $q.when(valuesFn(scope, controller))\n          .then(function (values) {\n            if (!angular.isArray(values)) {\n              values = [];\n            }\n            $parseOptions.$values = values.length ? parseValues(values, scope) : [];\n            return $parseOptions.$values;\n          });\n        };\n\n        $parseOptions.displayValue = function (modelValue) {\n          var scope = {};\n          scope[valueName] = modelValue;\n          return displayFn(scope);\n        };\n\n        // Private functions\n\n        function parseValues (values, scope) {\n          return values.map(function (match, index) {\n            var locals = {};\n            var label;\n            var value;\n            locals[valueName] = match;\n            label = displayFn(scope, locals);\n            value = valueFn(scope, locals);\n            return {label: label, value: value, index: index};\n          });\n        }\n\n        $parseOptions.init();\n        return $parseOptions;\n\n      }\n\n      return ParseOptionsFactory;\n\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dimensions', [])\n\n  .factory('dimensions', function () {\n\n    var fn = {};\n\n    /**\n     * Test the element nodeName\n     * @param element\n     * @param name\n     */\n    var nodeName = fn.nodeName = function (element, name) {\n      return element.nodeName && element.nodeName.toLowerCase() === name.toLowerCase();\n    };\n\n    /**\n     * Returns the element computed style\n     * @param element\n     * @param prop\n     * @param extra\n     */\n    fn.css = function (element, prop, extra) {\n      var value;\n      if (element.currentStyle) { // IE\n        value = element.currentStyle[prop];\n      } else if (window.getComputedStyle) {\n        value = window.getComputedStyle(element)[prop];\n      } else {\n        value = element.style[prop];\n      }\n      return extra === true ? parseFloat(value) || 0 : value;\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.offset = function (element) {\n      var boxRect = element.getBoundingClientRect();\n      var docElement = element.ownerDocument;\n      return {\n        width: boxRect.width || element.offsetWidth,\n        height: boxRect.height || element.offsetHeight,\n        top: boxRect.top + (window.pageYOffset || docElement.documentElement.scrollTop) - (docElement.documentElement.clientTop || 0),\n        left: boxRect.left + (window.pageXOffset || docElement.documentElement.scrollLeft) - (docElement.documentElement.clientLeft || 0)\n      };\n    };\n\n    /**\n     * Provides set equivalent of jQuery's offset function:\n     * @required-by bootstrap-tooltip\n     * @url http://api.jquery.com/offset/\n     * @param element\n     * @param options\n     * @param i\n     */\n    fn.setOffset = function (element, options, i) {\n      var curPosition;\n      var curLeft;\n      var curCSSTop;\n      var curTop;\n      var curOffset;\n      var curCSSLeft;\n      var calculatePosition;\n      var position = fn.css(element, 'position');\n      var curElem = angular.element(element);\n      var props = {};\n\n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        element.style.position = 'relative';\n      }\n\n      curOffset = fn.offset(element);\n      curCSSTop = fn.css(element, 'top');\n      curCSSLeft = fn.css(element, 'left');\n      calculatePosition = (position === 'absolute' || position === 'fixed') &&\n                          (curCSSTop + curCSSLeft).indexOf('auto') > -1;\n\n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = fn.position(element);\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (angular.isFunction(options)) {\n        options = options.call(element, i, curOffset);\n      }\n\n      if (options.top !== null) {\n        props.top = (options.top - curOffset.top) + curTop;\n      }\n      if (options.left !== null) {\n        props.left = (options.left - curOffset.left) + curLeft;\n      }\n\n      if ('using' in options) {\n        options.using.call(curElem, props);\n      } else {\n        curElem.css({\n          top: props.top + 'px',\n          left: props.left + 'px'\n        });\n      }\n    };\n\n    /**\n     * Provides read-only equivalent of jQuery's position function\n     * @required-by bootstrap-tooltip, bootstrap-affix\n     * @url http://api.jquery.com/offset/\n     * @param element\n     */\n    fn.position = function (element) {\n\n      var offsetParentRect = {top: 0, left: 0};\n      var offsetParentEl;\n      var offset;\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n      if (fn.css(element, 'position') === 'fixed') {\n\n        // We assume that getBoundingClientRect is available when computed position is fixed\n        offset = element.getBoundingClientRect();\n\n      } else {\n\n        // Get *real* offsetParentEl\n        offsetParentEl = offsetParentElement(element);\n\n        // Get correct offsets\n        offset = fn.offset(element);\n        if (!nodeName(offsetParentEl, 'html')) {\n          offsetParentRect = fn.offset(offsetParentEl);\n        }\n\n        // Add offsetParent borders\n        offsetParentRect.top += fn.css(offsetParentEl, 'borderTopWidth', true);\n        offsetParentRect.left += fn.css(offsetParentEl, 'borderLeftWidth', true);\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        width: element.offsetWidth,\n        height: element.offsetHeight,\n        top: offset.top - offsetParentRect.top - fn.css(element, 'marginTop', true),\n        left: offset.left - offsetParentRect.left - fn.css(element, 'marginLeft', true)\n      };\n\n    };\n\n    /**\n     * Returns the closest, non-statically positioned offsetParent of a given element\n     * @required-by fn.position\n     * @param element\n     */\n    function offsetParentElement (element) {\n      var docElement = element.ownerDocument;\n      var offsetParent = element.offsetParent || docElement;\n      if (nodeName(offsetParent, '#document')) return docElement.documentElement;\n      while (offsetParent && !nodeName(offsetParent, 'html') && fn.css(offsetParent, 'position') === 'static') {\n        offsetParent = offsetParent.offsetParent;\n      }\n      return offsetParent || docElement.documentElement;\n    }\n\n    /**\n     * Provides equivalent of jQuery's height function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/height/\n     * @param element\n     * @param outer\n     */\n    fn.height = function (element, outer) {\n      var value = element.offsetHeight;\n      if (outer) {\n        value += fn.css(element, 'marginTop', true) + fn.css(element, 'marginBottom', true);\n      } else {\n        value -= fn.css(element, 'paddingTop', true) + fn.css(element, 'paddingBottom', true) + fn.css(element, 'borderTopWidth', true) + fn.css(element, 'borderBottomWidth', true);\n      }\n      return value;\n    };\n\n    /**\n     * Provides equivalent of jQuery's width function\n     * @required-by bootstrap-affix\n     * @url http://api.jquery.com/width/\n     * @param element\n     * @param outer\n     */\n    fn.width = function (element, outer) {\n      var value = element.offsetWidth;\n      if (outer) {\n        value += fn.css(element, 'marginLeft', true) + fn.css(element, 'marginRight', true);\n      } else {\n        value -= fn.css(element, 'paddingLeft', true) + fn.css(element, 'paddingRight', true) + fn.css(element, 'borderLeftWidth', true) + fn.css(element, 'borderRightWidth', true);\n      }\n      return value;\n    };\n\n    return fn;\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.debounce', [])\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L693\n.factory('debounce', function ($timeout) {\n  return function (func, wait, immediate) {\n    var timeout = null;\n    return function () {\n      var context = this;\n      var args = arguments;\n      var callNow = immediate && !timeout;\n      if (timeout) {\n        $timeout.cancel(timeout);\n      }\n      timeout = $timeout(function later () {\n        timeout = null;\n        if (!immediate) {\n          func.apply(context, args);\n        }\n      }, wait, false);\n      if (callNow) {\n        func.apply(context, args);\n      }\n      return timeout;\n    };\n  };\n})\n\n\n// @source jashkenas/underscore\n// @url https://github.com/jashkenas/underscore/blob/1.5.2/underscore.js#L661\n.factory('throttle', function ($timeout) {\n  return function (func, wait, options) {\n    var timeout = null;\n    if (!options) options = {};\n    return function () {\n      var context = this;\n      var args = arguments;\n      if (!timeout) {\n        if (options.leading !== false) {\n          func.apply(context, args);\n        }\n        timeout = $timeout(function later () {\n          timeout = null;\n          if (options.trailing !== false) {\n            func.apply(context, args);\n          }\n        }, wait, false);\n      }\n    };\n  };\n});\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\n\n.provider('$dateParser', function ($localeProvider) {\n\n  // define a custom ParseDate object to use instead of native Date\n  // to avoid date values wrapping when setting date component values\n  function ParseDate () {\n    this.year = 1970;\n    this.month = 0;\n    this.day = 1;\n    this.hours = 0;\n    this.minutes = 0;\n    this.seconds = 0;\n    this.milliseconds = 0;\n  }\n\n  ParseDate.prototype.setMilliseconds = function (value) { this.milliseconds = value; };\n  ParseDate.prototype.setSeconds = function (value) { this.seconds = value; };\n  ParseDate.prototype.setMinutes = function (value) { this.minutes = value; };\n  ParseDate.prototype.setHours = function (value) { this.hours = value; };\n  ParseDate.prototype.getHours = function () { return this.hours; };\n  ParseDate.prototype.setDate = function (value) { this.day = value; };\n  ParseDate.prototype.setMonth = function (value) { this.month = value; };\n  ParseDate.prototype.setFullYear = function (value) { this.year = value; };\n  ParseDate.prototype.fromDate = function (value) {\n    this.year = value.getFullYear();\n    this.month = value.getMonth();\n    this.day = value.getDate();\n    this.hours = value.getHours();\n    this.minutes = value.getMinutes();\n    this.seconds = value.getSeconds();\n    this.milliseconds = value.getMilliseconds();\n    return this;\n  };\n\n  ParseDate.prototype.toDate = function () {\n    return new Date(this.year, this.month, this.day, this.hours, this.minutes, this.seconds, this.milliseconds);\n  };\n\n  var proto = ParseDate.prototype;\n\n  function noop () {\n  }\n\n  function isNumeric (n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function indexOfCaseInsensitive (array, value) {\n    var len = array.length;\n    var str = value.toString().toLowerCase();\n    for (var i = 0; i < len; i++) {\n      if (array[i].toLowerCase() === str) { return i; }\n    }\n    return -1; // Return -1 per the \"Array.indexOf()\" method.\n  }\n\n  var defaults = this.defaults = {\n    format: 'shortDate',\n    strict: false\n  };\n\n  this.$get = function ($locale, dateFilter) {\n\n    var DateParserFactory = function (config) {\n\n      var options = angular.extend({}, defaults, config);\n\n      var $dateParser = {};\n\n      /* eslint-disable key-spacing, quote-props */\n      var regExpMap = {\n        'sss'   : '[0-9]{3}',\n        'ss'    : '[0-5][0-9]',\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'mm'    : '[0-5][0-9]',\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\n        'HH'    : '[01][0-9]|2[0-3]',\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\n        'hh'    : '[0][1-9]|[1][012]',\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'a'     : 'AM|PM',\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        'MM'    : '0[1-9]|1[012]',\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\n        'yy'    : '[0-9]{2}',\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}'\n      };\n\n      var setFnMap = {\n        'sss'   : proto.setMilliseconds,\n        'ss'    : proto.setSeconds,\n        's'     : proto.setSeconds,\n        'mm'    : proto.setMinutes,\n        'm'     : proto.setMinutes,\n        'HH'    : proto.setHours,\n        'H'     : proto.setHours,\n        'hh'    : proto.setHours,\n        'h'     : proto.setHours,\n        'EEEE'  : noop,\n        'EEE'   : noop,\n        'dd'    : proto.setDate,\n        'd'     : proto.setDate,\n        'a'     : function (value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\n        'MMMM'  : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.MONTH, value)); },\n        'MMM'   : function (value) { return this.setMonth(indexOfCaseInsensitive($locale.DATETIME_FORMATS.SHORTMONTH, value)); },\n        'MM'    : function (value) { return this.setMonth(1 * value - 1); },\n        'M'     : function (value) { return this.setMonth(1 * value - 1); },\n        'yyyy'  : proto.setFullYear,\n        'yy'    : function (value) { return this.setFullYear(2000 + 1 * value); },\n        'y'     : function (value) { return (1 * value <= 50 && value.length === 2) ? this.setFullYear(2000 + 1 * value) : this.setFullYear(1 * value); }\n      };\n      /* eslint-enable key-spacing, quote-props */\n\n      var regex;\n      var setMap;\n\n      $dateParser.init = function () {\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\n        regex = regExpForFormat($dateParser.$format);\n        setMap = setMapForFormat($dateParser.$format);\n      };\n\n      $dateParser.isValid = function (date) {\n        if (angular.isDate(date)) return !isNaN(date.getTime());\n        return regex.test(date);\n      };\n\n      $dateParser.parse = function (value, baseDate, format, timezone) {\n        // check for date format special names\n        if (format) format = $locale.DATETIME_FORMATS[format] || format;\n        if (angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format, timezone);\n        var formatRegex = format ? regExpForFormat(format) : regex;\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\n        var matches = formatRegex.exec(value);\n        if (!matches) return false;\n        // use custom ParseDate object to set parsed values\n        var date = baseDate && !isNaN(baseDate.getTime()) ? new ParseDate().fromDate(baseDate) : new ParseDate().fromDate(new Date(1970, 0, 1, 0));\n        for (var i = 0; i < matches.length - 1; i++) {\n          if (formatSetMap[i]) formatSetMap[i].call(date, matches[i + 1]);\n        }\n        // convert back to native Date object\n        var newDate = date.toDate();\n\n        // check new native Date object for day values overflow\n        if (parseInt(date.day, 10) !== newDate.getDate()) {\n          return false;\n        }\n\n        return newDate;\n      };\n\n      $dateParser.getDateForAttribute = function (key, value) {\n        var date;\n\n        if (value === 'today') {\n          var today = new Date();\n          date = new Date(today.getFullYear(), today.getMonth(), today.getDate() + (key === 'maxDate' ? 1 : 0), 0, 0, 0, (key === 'minDate' ? 0 : -1));\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) { // Support {{ dateObj }}\n          date = new Date(value.substr(1, value.length - 2));\n        } else if (isNumeric(value)) {\n          date = new Date(parseInt(value, 10));\n        } else if (angular.isString(value) && value.length === 0) { // Reset date\n          date = key === 'minDate' ? -Infinity : +Infinity;\n        } else {\n          date = new Date(value);\n        }\n\n        return date;\n      };\n\n      $dateParser.getTimeForAttribute = function (key, value) {\n        var time;\n\n        if (value === 'now') {\n          time = new Date().setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.match(/^\".+\"$/)) {\n          time = new Date(value.substr(1, value.length - 2)).setFullYear(1970, 0, 1);\n        } else if (isNumeric(value)) {\n          time = new Date(parseInt(value, 10)).setFullYear(1970, 0, 1);\n        } else if (angular.isString(value) && value.length === 0) { // Reset time\n          time = key === 'minTime' ? -Infinity : +Infinity;\n        } else {\n          time = $dateParser.parse(value, new Date(1970, 0, 1, 0));\n        }\n\n        return time;\n      };\n\n      /* Handle switch to/from daylight saving.\n      * Hours may be non-zero on daylight saving cut-over:\n      * > 12 when midnight changeover, but then cannot generate\n      * midnight datetime, so jump to 1AM, otherwise reset.\n      * @param  date  (Date) the date to check\n      * @return  (Date) the corrected date\n      *\n      * __ copied from jquery ui datepicker __\n      */\n      $dateParser.daylightSavingAdjust = function (date) {\n        if (!date) {\n          return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n      };\n\n      /* Correct the date for timezone offset.\n      * @param  date  (Date) the date to adjust\n      * @param  timezone  (string) the timezone to adjust for\n      * @param  undo  (boolean) to add or subtract timezone offset\n      * @return  (Date) the corrected date\n      */\n      $dateParser.timezoneOffsetAdjust = function (date, timezone, undo) {\n        if (!date) {\n          return null;\n        }\n        // Right now, only 'UTC' is supported.\n        if (timezone && timezone === 'UTC') {\n          date = new Date(date.getTime());\n          date.setMinutes(date.getMinutes() + (undo ? -1 : 1) * date.getTimezoneOffset());\n        }\n        return date;\n      };\n\n      // Private functions\n\n      function regExpForFormat (format) {\n        // `format` string can contain literal values.\n        // These need to be escaped by surrounding with\n        // single quotes (e.g. `\"h 'in the morning'\"`).\n        // In order to output a single quote, escape it - i.e.,\n        // two single quotes in a sequence (e.g. `\"h 'o''clock'\"`).\n\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseRegex(re);\n      }\n\n      function buildDateAbstractRegex (format) {\n        var escapedFormat = escapeReservedSymbols(format);\n        var escapedLiteralFormat = escapedFormat.replace(/''/g, '\\\\\\'');\n        var literalRegex = /('(?:\\\\'|.)*?')/;\n        var formatParts = escapedLiteralFormat.split(literalRegex);\n        var dateElements = Object.keys(regExpMap);\n        var dateRegexParts = [];\n\n        angular.forEach(formatParts, function (part) {\n          if (isFormatStringLiteral(part)) {\n            part = trimLiteralEscapeChars(part);\n          } else {\n            // Abstract replaces to avoid collisions\n            for (var i = 0; i < dateElements.length; i++) {\n              part = part.split(dateElements[i]).join('${' + i + '}');\n            }\n          }\n          dateRegexParts.push(part);\n        });\n\n        return dateRegexParts.join('');\n      }\n\n      function escapeReservedSymbols (text) {\n        return text.replace(/\\\\/g, '[\\\\\\\\]')\n                   .replace(/-/g, '[-]')\n                   .replace(/\\./g, '[.]')\n                   .replace(/\\*/g, '[*]')\n                   .replace(/\\+/g, '[+]')\n                   .replace(/\\?/g, '[?]')\n                   .replace(/\\$/g, '[$]')\n                   .replace(/\\^/g, '[^]')\n                   .replace(/\\//g, '[/]')\n                   .replace(/\\\\s/g, '[\\\\s]');\n      }\n\n      function isFormatStringLiteral (text) {\n        return /^'.*'$/.test(text);\n      }\n\n      function trimLiteralEscapeChars (text) {\n        return text.replace(/^'(.*)'$/, '$1');\n      }\n\n      function buildDateParseRegex (abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var re = abstractRegex;\n\n        // Replace abstracted values\n        for (var i = 0; i < dateElements.length; i++) {\n          re = re.split('${' + i + '}').join('(' + regExpMap[dateElements[i]] + ')');\n        }\n\n        return new RegExp('^' + re + '$', ['i']);\n      }\n\n      function setMapForFormat (format) {\n        var re = buildDateAbstractRegex(format);\n        return buildDateParseValuesMap(re);\n      }\n\n      function buildDateParseValuesMap (abstractRegex) {\n        var dateElements = Object.keys(regExpMap);\n        var valuesRegex = new RegExp('\\\\${(\\\\d+)}', 'g');\n        var valuesMatch;\n        var keyIndex;\n        var valueKey;\n        var valueFunction;\n        var valuesFunctionMap = [];\n\n        /* eslint-disable no-cond-assign */\n        while ((valuesMatch = valuesRegex.exec(abstractRegex)) !== null) {\n          keyIndex = valuesMatch[1];\n          valueKey = dateElements[keyIndex];\n          valueFunction = setFnMap[valueKey];\n\n          valuesFunctionMap.push(valueFunction);\n        }\n\n        return valuesFunctionMap;\n      }\n\n      $dateParser.init();\n      return $dateParser;\n\n    };\n\n    return DateParserFactory;\n\n  };\n\n});\n","'use strict';\n\nangular.module('mgcrea.ngStrap.helpers.dateFormatter', [])\n\n  .service('$dateFormatter', function ($locale, dateFilter) {\n\n    // The unused `lang` arguments are on purpose. The default implementation does not\n    // use them and it always uses the locale loaded into the `$locale` service.\n    // Custom implementations might use it, thus allowing different directives to\n    // have different languages.\n\n    this.getDefaultLocale = function () {\n      return $locale.id;\n    };\n\n    // Format is either a data format name, e.g. \"shortTime\" or \"fullDate\", or a date format\n    // Return either the corresponding date format or the given date format.\n    this.getDatetimeFormat = function (format, lang) {\n      return $locale.DATETIME_FORMATS[format] || format;\n    };\n\n    this.weekdaysShort = function (lang) {\n      return $locale.DATETIME_FORMATS.SHORTDAY;\n    };\n\n    function splitTimeFormat (format) {\n      return /(h+)([:\\.])?(m+)([:\\.])?(s*)[ ]?(a?)/i.exec(format).slice(1);\n    }\n\n    // h:mm a => h\n    this.hoursFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[0];\n    };\n\n    // h:mm a => mm\n    this.minutesFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[2];\n    };\n\n    // h:mm:ss a => ss\n    this.secondsFormat = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => :\n    this.timeSeparator = function (timeFormat) {\n      return splitTimeFormat(timeFormat)[1];\n    };\n\n    // h:mm:ss a => true, h:mm a => false\n    this.showSeconds = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[4];\n    };\n\n    // h:mm a => true, H.mm => false\n    this.showAM = function (timeFormat) {\n      return !!splitTimeFormat(timeFormat)[5];\n    };\n\n    this.formatDate = function (date, format, lang, timezone) {\n      return dateFilter(date, format, timezone);\n    };\n\n  });\n","'use strict';\n\nangular.module('mgcrea.ngStrap.dropdown', ['mgcrea.ngStrap.tooltip'])\n\n  .provider('$dropdown', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'dropdown',\n      prefixEvent: 'dropdown',\n      placement: 'bottom-left',\n      templateUrl: 'dropdown/dropdown.tpl.html',\n      trigger: 'click',\n      container: false,\n      keyboard: true,\n      html: false,\n      delay: 0\n    };\n\n    this.$get = function ($window, $rootScope, $tooltip, $timeout) {\n\n      var bodyEl = angular.element($window.document.body);\n      var matchesSelector = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\n      function DropdownFactory (element, config) {\n\n        var $dropdown = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n        /* var scope = */$dropdown.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n\n        $dropdown = $tooltip(element, options);\n        var parentEl = element.parent();\n\n        // Protected methods\n\n        $dropdown.$onKeyDown = function (evt) {\n          if (!/(38|40)/.test(evt.keyCode)) return;\n          evt.preventDefault();\n          evt.stopPropagation();\n\n          // Retrieve focused index\n          var items = angular.element($dropdown.$element[0].querySelectorAll('li:not(.divider) a'));\n          if (!items.length) return;\n          var index;\n          angular.forEach(items, function (el, i) {\n            if (matchesSelector && matchesSelector.call(el, ':focus')) index = i;\n          });\n\n          // Navigate with keyboard\n          if (evt.keyCode === 38 && index > 0) index--;\n          else if (evt.keyCode === 40 && index < items.length - 1) index++;\n          else if (angular.isUndefined(index)) index = 0;\n          items.eq(index)[0].focus();\n\n        };\n\n        // Overrides\n\n        var show = $dropdown.show;\n        $dropdown.show = function () {\n          show();\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function () {\n            if (options.keyboard && $dropdown.$element) $dropdown.$element.on('keydown', $dropdown.$onKeyDown);\n            bodyEl.on('click', onBodyClick);\n          }, 0, false);\n          if (parentEl.hasClass('dropdown')) parentEl.addClass('open');\n        };\n\n        var hide = $dropdown.hide;\n        $dropdown.hide = function () {\n          if (!$dropdown.$isShown) return;\n          if (options.keyboard && $dropdown.$element) $dropdown.$element.off('keydown', $dropdown.$onKeyDown);\n          bodyEl.off('click', onBodyClick);\n          if (parentEl.hasClass('dropdown')) parentEl.removeClass('open');\n          hide();\n        };\n\n        var destroy = $dropdown.destroy;\n        $dropdown.destroy = function () {\n          bodyEl.off('click', onBodyClick);\n          destroy();\n        };\n\n        // Private functions\n\n        function onBodyClick (evt) {\n          if (evt.target === element[0]) return;\n          return evt.target !== element[0] && $dropdown.hide();\n        }\n\n        return $dropdown;\n\n      }\n\n      return DropdownFactory;\n\n    };\n\n  })\n\n  .directive('bsDropdown', function ($window, $sce, $dropdown) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      compile: function (tElement, tAttrs) {\n\n        // Support for inlined template (next sibling)\n        // It must be fetched before compilation\n        if (!tAttrs.bsDropdown) {\n          var nextSibling = tElement[0].nextSibling;\n          while (nextSibling && nextSibling.nodeType !== 1) {\n            nextSibling = nextSibling.nextSibling;\n          }\n          if (nextSibling && nextSibling.className.split(' ').indexOf('dropdown-menu') >= 0) {\n            tAttrs.template = nextSibling.outerHTML;\n            tAttrs.templateUrl = undefined;\n            nextSibling.parentNode.removeChild(nextSibling);\n          }\n        }\n\n        return function postLink (scope, element, attr) {\n\n          // Directive options\n          var options = {scope: scope};\n          angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'container', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'id', 'autoClose'], function (key) {\n            if (angular.isDefined(tAttrs[key])) options[key] = tAttrs[key];\n          });\n\n          // use string regex match boolean attr falsy values, leave truthy values be\n          var falseValueRegExp = /^(false|0|)$/i;\n          angular.forEach(['html', 'container'], function (key) {\n            if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n          });\n\n          // bind functions from the attrs to the show and hide events\n          angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n            var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n            if (angular.isDefined(attr[bsKey])) {\n              options[key] = scope.$eval(attr[bsKey]);\n            }\n          });\n\n          // Support scope as an object\n          if (attr.bsDropdown) {\n            scope.$watch(attr.bsDropdown, function (newValue, oldValue) {\n              scope.content = newValue;\n            }, true);\n          }\n\n          // Initialize dropdown\n          var dropdown = $dropdown(element, options);\n\n          // Visibility binding support\n          if (attr.bsShow) {\n            scope.$watch(attr.bsShow, function (newValue, oldValue) {\n              if (!dropdown || !angular.isDefined(newValue)) return;\n              if (angular.isString(newValue)) newValue = !!newValue.match(/true|,?(dropdown),?/i);\n              if (newValue === true) {\n                dropdown.show();\n              } else {\n                dropdown.hide();\n              }\n            });\n          }\n\n          // Garbage collection\n          scope.$on('$destroy', function () {\n            if (dropdown) dropdown.destroy();\n            options = null;\n            dropdown = null;\n          });\n\n        };\n      }\n    };\n\n  });\n","'use strict';\n\n// @BUG: following snippet won't compile correctly\n\nangular.module('mgcrea.ngStrap.alert', ['mgcrea.ngStrap.modal'])\n\n  .provider('$alert', function () {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      prefixClass: 'alert',\n      prefixEvent: 'alert',\n      placement: null,\n      templateUrl: 'alert/alert.tpl.html',\n      container: false,\n      element: null,\n      backdrop: false,\n      keyboard: true,\n      show: true,\n      // Specific options\n      duration: false,\n      type: false,\n      dismissible: true\n    };\n\n    this.$get = function ($modal, $timeout) {\n\n      function AlertFactory (config) {\n\n        var $alert = {};\n\n        // Common vars\n        var options = angular.extend({}, defaults, config);\n\n        $alert = $modal(options);\n\n        // Support scope as string options [/*title, content, */ type, dismissible]\n        $alert.$scope.dismissible = !!options.dismissible;\n        if (options.type) {\n          $alert.$scope.type = options.type;\n        }\n\n        // Support auto-close duration\n        var show = $alert.show;\n        if (options.duration) {\n          $alert.show = function () {\n            show();\n            $timeout(function () {\n              $alert.hide();\n            }, options.duration * 1000);\n          };\n        }\n\n        return $alert;\n\n      }\n\n      return AlertFactory;\n\n    };\n\n  })\n\n  .directive('bsAlert', function ($window, $sce, $alert) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink (scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope, element: element, show: false};\n        angular.forEach(['template', 'templateUrl', 'controller', 'controllerAs', 'placement', 'keyboard', 'html', 'container', 'animation', 'duration', 'dismissible'], function (key) {\n          if (angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['keyboard', 'html', 'container', 'dismissible'], function (key) {\n          if (angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key])) options[key] = false;\n        });\n\n        // bind functions from the attrs to the show and hide events\n        angular.forEach(['onBeforeShow', 'onShow', 'onBeforeHide', 'onHide'], function (key) {\n          var bsKey = 'bs' + key.charAt(0).toUpperCase() + key.slice(1);\n          if (angular.isDefined(attr[bsKey])) {\n            options[key] = scope.$eval(attr[bsKey]);\n          }\n        });\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')) {\n          scope.title = '';\n        }\n\n        // Support scope as data-attrs\n        angular.forEach(['title', 'content', 'type'], function (key) {\n          if (attr[key]) {\n            attr.$observe(key, function (newValue, oldValue) {\n              scope[key] = $sce.trustAsHtml(newValue);\n            });\n          }\n        });\n\n        // Support scope as an object\n        if (attr.bsAlert) {\n          scope.$watch(attr.bsAlert, function (newValue, oldValue) {\n            if (angular.isObject(newValue)) {\n              angular.extend(scope, newValue);\n            } else {\n              scope.content = newValue;\n            }\n          }, true);\n        }\n\n        // Initialize alert\n        var alert = $alert(options);\n\n        // Trigger\n        element.on(attr.trigger || 'click', alert.toggle);\n\n        // Garbage collection\n        scope.$on('$destroy', function () {\n          if (alert) alert.destroy();\n          options = null;\n          alert = null;\n        });\n\n      }\n    };\n\n  });\n","\nangular.module('mgcrea.ngStrap', [\n  'mgcrea.ngStrap.modal',\n  'mgcrea.ngStrap.alert',\n  'mgcrea.ngStrap.select',\n  'mgcrea.ngStrap.datepicker',\n  'mgcrea.ngStrap.timepicker',\n  'mgcrea.ngStrap.tooltip',\n  'mgcrea.ngStrap.popover',\n  'mgcrea.ngStrap.dropdown',\n  'mgcrea.ngStrap.tab',\n  'mgcrea.ngStrap.pagination',\n  'mgcrea.ngStrap.sort'\n]);\n"],"sourceRoot":"/source/"}